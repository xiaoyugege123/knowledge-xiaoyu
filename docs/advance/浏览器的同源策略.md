# 浏览器的同源策略

## 浏览器会对跨域做出那些限制？

1. DOM 访问限制：【源 A】的脚本不能读取和操作【源 B】的 DOM。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button onclick="showDom()">获取页面2的DOM</button>
    <!-- 同源，能获取到DOM -->
    <iframe id="frame" src="./z.html" frameborder="0"></iframe>

    <!-- 非同源，报错！！！ -->
    <!-- <iframe id="frame" src="https://www.bilibili.com/" frameborder="0"></iframe> -->
    <script>
      function showDom() {
        const frame = document.getElementById("frame");
        console.log(frame.contentWindow.document);
      }
    </script>
  </body>
</html>
```

2. Cookie 访问限制：【源 A】不能访问【源 B】的 cookie

JS 获取 cookie 的方式，documnet.cookie，上面一步知道不能获取非同源网站的 DOM，自然也不好获取到 cookie。

3. AJAX 响应数据限制：【源 A】可以给【源 B】发请求，但是无法获取【源 B】响应的数据。（影响最大！！！）

## 几个注意点

1. 跨域限制仅存在浏览器端，服务端不存在跨域限制。
2. 即使跨域了，AJax 请求也可以正常发出，但响应数据不会交给开发者。
   ![跨域问题](/imgs/跨域问题.png)
3. `<link>`、`<script>`、`<img>`……这些标签发出去的请求也可能跨域，只不过浏览器对标签跨域不做严格限制，对开发几乎无影响。(可以配置 CSP)

## CORS 解决 AJAX 跨域问题

**CORS 概述**

CORS 全称：`Cross-Origin Resource Sharing`(跨域资源共享)，是用于`浏览器校验`跨域请求的一套规范，服务器依照 CORS 规范，添加特定`响应头`来控制浏览器校验，大致规则如下：

- 服务器明确表示`拒绝请求`，或者`没有表示`，则浏览器校验`不通过`。
- 服务器明确表示`允许跨域请求`，则浏览器校验`通过`。
  > 备注说明：使用 CORS 解决跨域是最正统的方式，且要求服务器是“自己人”。

**CORS 解决简单请求跨域**
简单请求解决代码
```js
app.get('/students',(req,res)=>{
    res.setHeader("Access-Control-Allow-Origin","http://127.0.0.1:5500")
    res.send(students)
})
```

**简单请求与复杂请求**

CORS 会把请求分为两类，分别是：简单请求、复杂请求

**简单请求：**

1. 请求方法为：`GET`、`HEAD`、`POST`
2. 请求头字段要符合《CORS 安全规范》<br> 简记：只要不动手修改请求头，一般都能符合规范
3. 请求头的`Content-Type`的值只能是一下三种：
   - `text/plain`
   - `multipart/form-data`
   - `application/x-www-form-urlencoded`

**复杂请求**

1. 不是简单请求，就是复杂请求
2. 复杂请求会自动发送`预检请求`

**关于预检请求：**

1. 发送时机：预检请求在实际跨域请求之前发出，是由浏览器自动发起的。
2. 主要作用：用于向服务器确认是否允许接下来的跨域请求。
3. 基本流程：发起`options`请求，如果通过预检，继续发起实际的跨域请求。
4. 请求头内容：一个`options`预检请求，通常会包含如下请求头：
   |请求头|含义|
   |----|------|
   |`Origin`|发起请求的源|
   |`Access-Control-Request-Method`|实际请求的HTTP方法|
   |`Access-Control-Request-Headers`|实际请求中使用的自定义头（如果有的话）|

**CORS解决复杂请求跨域**
1.第一步：服务器先通过浏览器的预检请求，服务器需要返回如下响应头：
|请求头|含义| 
|---|---| 
|`Access-Control-Allow-Origin`|允许的源|
|`Access-Control-Allow-Methods`|允许的方法|
|`Access-Control-Allow-Headers`|允许的自定义头|
|`Access-Control-Max-Age`|预检请求的结果缓存时间（可选）|


![预检请求](/imgs/预检请求.png)

复杂请求解决代码
```js
app.get('/students',(req,res)=>{
    res.setHeader("Access-Control-Allow-Origin","http://127.0.0.1:5500")
    res.send(students)
})

app.options("/students",(req,res)=>{
    res.setHeader('Access-Control-Allow-Origin',"http://127.0.0.1:5500")
    res.setHeader('Access-Control-Allow-Methods',"GET")
    //浏览器带来的请求头中可能存在
    res.setHeader('Access-Control-Allow-Headers',"school,city")
    res.setHeader('Access-Control-Max-Age',7200)
    res.send()
})
```

2. 第二步：处理实际的跨域请求（与处理简单跨域请求的方式相同）

**利用cors库解决跨域**
- 简单配置
```js
app.use(cors())
```
- 完整配置
```js
// cors中间件配置
const corsOptions={
    origin:'http://127.0.0.1:5500',//允许的源
    methods:['GET','POST','PUT','DELETE','HEAD','OPTIONS'],//允许的方法
    allowedHeaders:['school'],//允许的自定义头
    exposedHeaders:['abs'],//要暴露的响应头
    optionsSuccessStatus:200 // 预检请求成功的状态码
}
app.use(cors(corsOptions))
```

## JSONP 解决跨域问题
1. JSONP概述：JSONP是利用了`<script>`标签可以跨域加载脚本，且不受严格限制的特性，可以说是程序员智慧的结晶，早起一些浏览器不支持CORS的时候，可以考JSONP解决跨域。
2. 基本流程：
    - 第一步：客户端创建一个`<script>`标签，并将其src属性设置为包含跨域请求的URL，同时准备一个回调函数，这个回调函数用于处理返回的数据。
    - 第二步：服务器接收到请求后，将数据封装在回调函数中并返回。
    - 第三步：客户端的回调函数被调用，数据以参数的形式传入回调函数。

![JSONP解决跨域问题](/imgs/JSONP解决跨域问题.png)

客户端代码
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <button onclick="getStudents()">获取学生数据</button>

    <script>
        function test(data){
            console.log(data);
        }
        function getStudents(){
            const script =document.createElement('script')
            script.onload=()=>{
                script.remove()
            }
            script.src="http://127.0.0.1:8081/teachers?callback=test"
            document.body.append(script)
        }
    </script>
</body>
</html>
```
服务端代码：
```js
app.get('/teachers',(req,res)=>{
    const {callback}=req.query
    res.send(`${callback}(${JSON.stringify(teachers)})`)
})
```

## 配置代理服务器

**自己配置代理服务器**
> 利用 `http-proxy-middleware` 这个库去配置
```js
const {createProxyMiddleWare}=require('http-proxy-middleware')

app.use('/api',createProxyMiddleWare({
    target:'https://www.toutiao.com',
    changeOrigin:true,
    pathRewrite:{
        '^/api':''
    }
}))

// 实际请求：https://www.toutiao.com/news/today
// 客户端请求：http:127.0.0.1:8086/api/news/today  
```

**利用NGINX配置代理服务器**

**脚手架配置代理服务器**

> 面试的时候可以提自己配代理，和NGINX配置代理。