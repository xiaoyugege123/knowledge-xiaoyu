# 正则表达式

## 正则表达式速查

```:no-line-numbers
匹配模式：
    i:忽略大小写
    g:执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
    m:执行多行匹配。


正则表达式模式
方括号：（好像里面不能写括号）
    [abc]:查找方括号之间的任何字符。
    [0-9]:查找任何从 0 至 9 的数字。
    (x|y):查找由 | 分隔的任何选项。
    [a-z]:查找任何小写的字母。[A-z]:字母
    [^ ]:除了。。。
    [^0-9]:除了数字
量词：(只对前面的一个内容起作用，内容可以用()括号圈起来为一个)
    n+	匹配任何包含至少一个 n 的字符串。
    n*	匹配任何包含零个或多个 n 的字符串。
    n?	匹配任何包含零个或一个 n 的字符串。（要么没有，要么就一个）
    n{X}	匹配包含 X 个 n 的序列的字符串。
    n{X,Y}	匹配包含 X 至 Y 个 n 的序列的字符串。
    n{X,}	匹配包含至少 X 个 n 的序列的字符串。
    n$	匹配任何结尾为 n 的字符串。
    ^n	匹配任何开头为 n 的字符串。
    ?=n	匹配任何其后紧接指定字符串 n 的字符串。有点像以什么结尾的一样
    ?!n	匹配任何其后没有紧接指定字符串 n 的字符串。


元字符：
    .	查找单个字符，除了换行和行结束符。
    \w	查找单词字符。
    \W	查找非单词字符。
    \d	查找数字。
    \D	查找非数字字符。
    \s	查找空白字符。
    \S	查找非空白字符。
    \b	匹配单词边界。
    \B	匹配非单词边界。
    \0	查找 NUL 字符。
    \n	查找换行符。
    \f	查找换页符。
    \r	查找回车符。
    \t	查找制表符。
    \v	查找垂直制表符。
    \xxx	查找以八进制数 xxx 规定的字符。
    \xdd	查找以十六进制数 dd 规定的字符。
    \uxxxx	查找以十六进制数 xxxx 规定的 Unicode 字符。
注意点：
    \w 匹配包括下划线的任何单词字符，等同于[A-Za-z0-9_]
    \W 匹配任何非单词字符，等同于[^A-Za-z0-9_]

    \s 匹配空格、换行、tab缩进等所有的空白
    \S 匹配非空白，跟\s刚好相反。

    "gssghs"    \w  true
    "123433"    \w  true
    "_"         \w  true
    "     "     \s  true    



RegExp 对象方法：
    test():它通过模式来搜索字符串，然后根据结果返回 true 或 false。
    exec():	检索字符串中指定的值。返回找到的值，并确定其位置。
        -返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。
        -  此数组的第 0 个元素是与正则表达式相匹配的文本，后续捕获组。


支持正则表达式的 String 对象的方法:
split()
    -可以将一个字符串拆分为一个数组
    -方法中可以传递一个正则表达式作为一个参数，这样方法会根据正则表达式去拆分字符串
search()
    -可以搜索字符串是否含有指定内容
    -如果搜索到指定内容，则会返回第一次出现的索引，如果没有返回-1
    -也可以接受一个正则表达式，根据去查找
    -search()只会查找第一个，即使设置全局匹配也是这样
match()
    -根据正则表达式，从一个字符串中将符合条件的内容提取出来
    -默认情况下，我们match只会找到第一个符合条件的内容，找到以后停止搜索，
        我们可以设置正则表达式全局匹配，这样就能匹配到所有符合要求的
        可以设置多个匹配模式，模式顺序任意
    -match()匹配到的内容会封装到一个数组中返回
replace()
    -可以将字符串指定的内容替换为新的内容
    -参数：1、被替换的内容，可以接受一个正则表达式作为一个参数。2、新的内容
    -默认只会替换一个


汉字：[\u4e00-\u9fa5]
```
**推荐文章**

[位置匹配 理解正则中的(?=p)、(?!p)、(?<=p)、(?<!p)](https://juejin.cn/post/6844903943684751368)


## 正则应用
**信息脱敏**
```js
const phone="13212345678"
const phoneReg=/^(\d{3})(?:\d{5})(\d{3})$/
// 这里用了捕获组和非捕获组

const str=phone.replace(phoneReg,"$1*****$2")
console.log(str)// 132*****678
```
**Markdown图片格式转H5 img标签**
```js
// 正则 + repalce方法
let str="![图片](./images/md.jpg)"
let imgReg=/^!\[(.*)\]\((.*)\)$/

// 除了字符串，还能函数！！！
const result=str.replace(imgReg,(match,alt,src)=>{
    console.log(match);//'![图片](./images/md.jpg)' 
    return `<img src="${src}" alt="${alt}">`
})
console.log(result);//<img src="./images/md.jpg" alt="图片"> 
```
**正则引用——子表达式**
```js
// 引用: 后面可以用\1引用编号为1的子表达式，依次类推，比如:
var pattern = /(A|B)(\d{5})not([o-9])\1\2/;//pattern在最后引用了第一个和第二个子表达式。
// 注意:这里的引用是对与子表达式匹配的字符串的引用，而不是简单的对子表达式的引用。例如:
var pattern = /([0-9])AA\1/;
// pattern不等价于正则表达式([0-9])AA[0-9]，
// 而是指字符串AA后面的数字必须和前面的相同，即形如1AA1这样的字符串！

//特殊正则匹配
let str="A12345not7A12345"
var pattern = /(A|B)(\d{5})not([o-9])\1\2/;
console.log(pattern.exec(str));
//['A12345not7A12345' , 'A' , '12345' , ' 7 ' , index: 0,input: 'A12345not7A12345' ,groups: undefined ]
```

**贪婪匹配和非贪婪匹配**
```js
const sanitizedwithoutScript = text.replace(/<script[^>]*>.*?<\/script>/gi,"");
```
非贪婪匹配(non-greedy matching)是正则表达式中的一个概念，与贪婪匹配相对。
- 在贪婪匹配中，正则引擎会尽可能多地匹配字符，直到达到最长的可能匹配。
- 而非贪婪匹配则尽可能少地匹配字符，直到达到最短的可能匹配。

例如，考虑正则表达式a+b。
> 如果用于贪婪匹配，它会匹配尽可能多的a字符，直到遇到一个b字符。如果用于非贪婪匹配，它会匹配尽可能少的a字符，直到遇到一个b字符。

- 在大多数现代正则表达式引擎中，可以通过在量词后面添加一个问号来实现非贪婪匹配，例如a+?、*?、+?等。
- 在您提供的正则表达式中，.*?就是一个非贪婪的量词，它会尽可能少地匹配字符，直到遇到下一个<或<\/script>。

>非贪婪匹配和贪婪匹配的主要区别在于它们在匹配字符串时的优先级和范围。<br><br>
> 在贪婪模式下，匹配器会尽可能多地匹配符合要求的字符，直到不能再匹配为止。<br>
> 例如，正则表达式a.*b在匹配字符串"abbcab"时，会匹配整个字符串"abbcab"，而不是期望的"ab"。<br><br>
>而非贪婪模式则相反，匹配器会尽可能少地匹配符合要求的字符，直到满足要求为止。<br>
> 例如，正则表达式a.*?b在匹配相同字符串"abbcab"时，只会匹配到第一个"ab"，而不是整个字符串。简而言之，贪婪模式尝试匹配尽可能多的字符，而非贪婪模式则尝试匹配尽可能少的字符。





## 八个常用的正则

##### 手机号码

- 前两位一般是 13 / 14 / 15 / 17 / 18
- 号码总长为 11 位

```js
let reg = /^1[34578]\d{9}$/g;
```

##### QQ 号码

- 首先第一个数不为 0
- 5-10 位的 QQ 号码

```js
let reg = /^[1-9][0-9]{4,9}$/g;
```

##### 十六进制颜色

- 第一个符号 # 可有可无
- 十六进制 0-9a-f
- #49D1CC 和 #0AB

```js
let reg = /#?([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;
```

##### 邮箱

- 允许输入的邮箱名称包含所有大小写字母、所有数字、以及\_-.三个符号
- luoyu2003@outlook.com

```js
let reg = /^([A-Za-z0-9_\-\.]+)@([A-Za-z0-9_\-\.]+)\.([A-Za-z]{2,6})$/g;
```

##### URL

- 协议的几种类型，协议可有可无
- 域名 顶级域名 和 根域名（特殊情况 com.cn）
- path 路径
- 最后可能以 / 结尾

```js
let reg =
  /^((https?|ftp|file):\/\/)?([\da-z\.\-]+)\.([a-z\.]{2,6})([\/\w\.\-]*)*\/?/g;
```

##### HTML 标签

**?:出现在括号的开头表示不需要捕获该组！！！**

```js
let reg = /^<([a-z]+)([^>]+)*(?:(.*)<\/\1>|\s+\/>)$/gm;
```

##### IPV4 地址

- 地址是由 4 组 0-255 的数字组成
- 每一组 0-255 我们需要进行数字范围拆分（正则没有直接表示数字范围的代码）
- 我们可以分为 0-199 | 200-249 | 250-255 三种范围

```js
let reg =
  /^(([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])$/g;
```

##### 日期 YYYY-mm-dd

- 注意格式
- 月份、日两位,不足前面补零
- 日有三种情况 0-9 | 10-29 | 30-31

```js
let reg = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/gm;
```
