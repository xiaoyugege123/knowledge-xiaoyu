# 高级的小知识点系列

## 为什么 height:100%; 不起作用

当设置一个页面元素的高度(height)为 100%时，期望这样元素能撑满整个浏览器窗口的高度，但大多数情况下，这样的做法没有任何效果。你知道为什么 height:100%不起作用吗？

按常理，当我们用 CSS 的 height 属性定义一个元素的高度时，这个元素应该按照设定在浏览器的纵向空间里扩展相应的空间距离。例如，如果一个 div 元素的 CSS 是 height: 100px;，那它应该在页面的竖向空间里占满 100px 的高度。

> 而根据 W3C 的规范，百分比的高度在设定时需要根据这个元素的父元素容器的高度。所以，如果你把一个 div 的高度设定为 height: 50%;，而它的父元素的高度是 100px，那么，这个 div 的高度应该是 50px。

当设计一个页面时，你在里面放置了一个 div 元素，你希望它占满整个窗口高度，最自然的做法，你会给这个 div 添加 height: 100%;的 css 属性。然而，如果你要是设置宽度为 width: 100%;，那这个元素的宽度会立刻扩展到窗口的整个横向宽度。高度也会这样吗？

错。

为了理解为什么不会，你需要理解浏览器是如何计算高度和宽度的。Web 浏览器在计算有效宽度时会考虑浏览器窗口的打开宽度。如果你不给宽度设定任何缺省值，那浏览器会自动将页面内容平铺填满整个横向宽度。

但是高度的计算方式完全不一样。事实上，浏览器根本就不计算内容的高度，除非内容超出了视窗范围(导致滚动条出现)。或者你给整个页面设置一个绝对高度。否则，浏览器就会简单的让内容往下堆砌，页面的高度根本就无需考虑。

因为页面并没有缺省的高度值，所以，当你让一个元素的高度设定为百分比高度时，无法根据获取父元素的高度，也就无法计算自己的高度。换句话说，**父元素的高度只是一个缺省值：height: auto;。** `当你要求浏览器根据这样一个缺省值来计算百分比高度时，只能得到undefined的结果。也就是一个null值，浏览器不会对这个值有任何的反应。`

解决办法

那么，如果想让一个元素的百分比高度 height: 100%;起作用，你需要给这个元素的所有父元素的高度设定一个有效值。换句话说，你需要这样做：

```html
<html style="height: 100%;">
  <body style="height: 100%;">
    <div style="height: 100%;">
      <p>这个div的高度就会100%了</p>
    </div>
  </body>
</html>
```

现在你给了这个 div 的高度为 100%，它有两个父元素`<body>`和`<html>`。为了让你的 div 的百分比高度能起作用，你必须设定`<body>`和`<html>`的高度为 100%。

使用 height: 100%;时的注意事项

1. Margins 和 padding 会让你的页面出现滚动条，也许这是你不希望的。
2. 如果你的元素实际高度大于你设定的百分比高度，那元素的高度会自动扩展。

## 什么是尾调用

尾部调用不会让栈（stack）无限制地增长。这让 递归算法在面对不做限制的输入时能够安全执行。

```js
function factorial(n, acc = 1) {
    "use strict";
    if (n <= 1) return acc;
    return factorial(n - 1, n * acc);
}

// 在如今的大部分实现中都将引起栈溢出（Stack overflow），
// 但是在 ES2015 中处理任意数量的输入都是安全的
factorial(100000)
```

尾调用就是在函数执行的最后一步执行另一个函数。如下所示为尾调用：

```js
function f(x) {
  return g(x);
}
```

下面的两种情况都不属于尾调用

```js
function f(x) {
  let y = g(x);
  return y;
}
```

```js
function f(x) {
  return g(x) + 1;
}
```

通过一个例子来看尾调用

```js
function a() {
  return b() + 1;
}

function b() {
  return c() + 2;
}

function c() {
  return 3;
}

console.log(a()); //6
```

```js
function a() {
  return b(1);
}

function b(num) {
  return c(num + 2);
}

function c(num) {
  return num + 3;
}

console.log(a()); //6
```

上面那种情况不是尾调用，下面的是尾调用。

**为什么说尾调用的性能要比没有使用尾调用的性能好呢？**

> 我们都知道在 A 函数调用时会将 A 函数放入调用栈中，如果在 A 函数中存在另一个函数 B 调用，此时也会将 B 压入调用栈中，等待函数 B 调用完成后，此时才可以从调用栈中弹出函数 A 和函数 B。那如果使用尾调用时，当执行函数 A 时，将函数 A 压入调用栈中，`当执行 A 时发现存在函数 B，并且函数 B 为函数 A 的最后一步调用，此时可以将函数 A 从调用栈中弹出，将函数 B 压入调用栈中`。这样下来性能就做到了优化。

**严格模式**

ES6 中的尾调用优化只在严格模式下开启，正常模式下无效。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。

```
arguments：返回调用时函数的参数。
func.caller：返回调用当前函数的那个函数。
```

尾调用优化时，函数的调用栈会被改写，因此上面的两个变量就会失真。严格模式下禁用这两个变量，所以尾调用模式仅在严格模式下生效。
