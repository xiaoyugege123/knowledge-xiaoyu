# 手写题

## 前端面试常考

### 1.实现一个 call 函数

```js
Function.prototype.myCall = function (context) {
  var context = context || window;
  //给context添加一个属性
  //getValue.call(a,'yck',24) => a.fn=getValue
  context.fn = this;
  //将context后面的参数全部取出
  var args = [...arguments].slice(1);
  //进行实现，这里改变了this->context
  //getValue.call(a,'yck',24) => a.fn('yck',24)
  var reslut = context.fn(...args);
  //删除 fn
  delete context.fn;
  return reslut;
};

/* 黑马：手写call
  1、定义myCall方法
  2、设置this并调用原函数
  3、接收剩余参数并返回结果
  4、使用Symbol调优
*/
Function.prototype.myCall = function (thisArg, ...args) {
  //下面这里有个小小的隐患，如果thisArg传进来的对象已经存在了f这个属性，那么下面这行代码会覆盖之前的值
  //解决：给thisArg加一个一定不重名的新属性
  let key = Symbol("key");
  thisArg[key] = this;
  const res = thisArg[key](...args);
  //这里要去除，要不然后面的对象会新出现这个属性
  delete thisArg[key];
  return res;
};
```

### 2.实现一个 apply 函数

```js
Function.prototype.myApply = function (context) {
  var context = context || window;
  context.fn = this;

  var reslut;
  //需要判断是否存储第二个参数，如果存在，就将第二个参数展开
  if (arguments[1]) {
    reslut = context.fn(...arguments[1]);
  } else {
    reslut = context.fn();
  }

  delete context.fn;
  return reslut;
};

/* 手写apply函数  */
Function.prototype.myApply = function (thisArg, args) {
  let fn = Symbol("fn");
  thisArg[fn] = this;
  const result = thisArg[fn](args);
  delete thisArg[fn];
  return result;
};
```

### 3.实现一个 bind 函数

```js
/* 首先了解一下bind函数 */
//bind() 最简单的用法是创建一个函数，无论如何调用，它都会使用特定的 this 值进行调用。
// 顶级的“this”绑定到“globalThis”。
this.x = 9;
const module = {
  x: 81,
  getX() {
    return this.x;
  },
};

// “getX”的“this”参数绑定到“module”。
console.log(module.getX()); // 81

const retrieveX = module.getX;
// “retrieveX”的“this”参数在非严格模式下绑定到“globalThis”。
console.log(retrieveX()); // 9

// 创建一个新函数“boundGetX”，并将“this”参数绑定到“module”。
const boundGetX = retrieveX.bind(module);
console.log(boundGetX()); // 81

//bind() 的另一个简单用法是创建一个具有预设初始参数的函数。
function list(...args) {
  return args;
}

function addArguments(arg1, arg2) {
  return arg1 + arg2;
}

console.log(list(1, 2, 3)); // [1, 2, 3]

console.log(addArguments(1, 2)); // 3

// 创建一个带有预设前导参数的函数
const leadingThirtySevenList = list.bind(null, 37);

// 创建一个带有预设第一个参数的函数。
const addThirtySeven = addArguments.bind(null, 37);

console.log(leadingThirtySevenList()); // [37]
console.log(leadingThirtySevenList(1, 2, 3)); // [37, 1, 2, 3]
console.log(addThirtySeven(5)); // 42
console.log(addThirtySeven(5, 10)); // 42
//（最后一个参数 10 被忽略）

//实现一个bind函数
Function.prototype.myBind = function (context) {
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  var _this = this;
  var args = [...arguments].slice(1); //这里的arguments是myBind这个函数的参数
  //返回一个函数
  return function F() {
    //因为返回了一个函数，我们可以new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments); //这里的arguments是F这个函数的参数
    }
    return _this.apply(context, args.concat(...arguments));
  };
};

/* 实现一个bind方法 
  1、定义myBind方法
  2、返回绑定this的新函数
  3、合并绑定和新传入的参数 
  */
//1.定义myBind方法
Function.prototype.myBind = function (thisArg, ...args) {
  // 2.返回绑定this的新函数
  return (...reArgs) => {
    // this:原函数(原函数.myBind)
    return this.call(thisArg, ...args, ...reArgs);
  };
};

//实现一个bind函数
Function.prototype.myBind = function (thisArg, ...args) {
  let _this = this;
  return function () {
    return _this.call(thisArg, ...args, ...arguments);
  };
};
```

### 4.实现 instanceof

```js
//instanceof 可以正确判断对象的基本类型，因为内部机制是通过判断对象的原型链中是不是能够找到类型的 prototype

function instance(left, right) {
  //对象 和 类型
  //获得类型的原型
  let prototype = right.prototype;
  //   获得对象的原型
  left = left.__proto__;
  //   判断对象类型是否等于类型的原型
  while (true) {
    if (left === null) {
      //已经往上找不到了，没有原型了
      return false;
    }
    if (prototype === left) {
      return true;
    }
    left = left.__proto__;
  }
}

let arr = [];
console.log(instance(arr, Array));
```

### 5.实现一个 new

```js
/* 
在调用new的过程中会发生如下四件事情
1.新生成了一个对象
2.链接到了原型
3.绑定this
4.返回新对象
*/
function _new(constructor, ...args) {
  //创建一个新的对象
  var obj = new Object();
  //链接到原型
  obj.__proto__ = constructor.prototype;
  //绑定this，执行构造函数
  var res = constructor.apply(obj, args);
  //确保new出来的是一个对象
  return typeof res === "object" ? res : obj;
}

function Fun(name) {
  this.name = name;
}
console.log(new Fun("xiao"));
console.log(_new(Fun, "xiaoyu"));
```

### 6.Generator-id 生成器

```js
// **需求:**使用`Generator`实现一个id生成器id

function* idGenerator() {
  let id = 0;
  while (true) {
    yield id++;
  }
}

const idMaker = idGenerator();

const { value: id1 } = idMaker.next();
const { value: id2 } = idMaker.next();
const { value: id3 } = idMaker.next();

console.log(id1, id2, id3);
```

### 7.函数柯里化一道面试题

```js
/**
 * 改写函数，实现如下效果
 *
 * function sum(a,b,c,d){
 *  return a+b+c+d
 * }
 *
 * //改写函数，参数传递5个即可累加实现
 * sum(1)(2)(3)(4)(5)
 * sum(1)(2,3)(4)(5)
 * sum(1)(2,3,4)(5)
 * sum(1,2)(3,4,5)
 *  */

let arr = []; //保存不定长数组
function sum(...args) {
  arr.push(...args);
  if (arr.length >= 5) {
    //进行累加
    let res = arr.slice(0, 5).reduce((cur, pre) => pre + cur, 0);
    arr = [];
    return res;
  } else {
    return sum;
  }
}

console.log(sum(1)(2)(3, 5, 4, 1));
```

### 8.实现一个管道函数

```js
function fn1(x) {
  return x + 1;
}
function fn2(x) {
  return x * 2;
}

// function pine(...fns){
//     return function(x){
//         return fns.reduce((acc,fn)=>{
//             return fn(acc)
//         },x)
//     }
// }

const pineline = pine([fn1, fn2]);
const output = pineline(5);
console.log(output);

function pine(fns) {
  return function (x) {
    return fns.reduce((prevRes, fn) => fn(prevRes), x);
  };
}
```

### 9.手写 loadsh_get 方法

```js
// input
const obj = {
  选择器: { to: { toutiao: "FE Coder" } },
  target: [1, 2, { name: "byted" }],
};
get(obj, "选择器.to.toutiao", "target[0]", "target[2].name");

// output
["FE coder", 1, "byted"];

function get(object, ...path) {
  return path.map((item) => {
    let res = object;
    item
      .replace(/\[/g, ".")
      .replace(/\]/g, "")
      .split(".")
      .map((path) => (res = res && res[path]));
    return res;
  });
}
```

```{9-13}
在表达式 obj & & obj ['a']中，计算第一个对象。

如果是 false 整个表达式就是 false 结果就是第一个操作数,

如果对象是真实的，那么第二部分

Obj['a']将被求值，其结果将是表达式的最终结果。

let obj = { a: 42 };
let result = obj && obj['a']; // result will be 42

obj = null;
result = obj && obj['a']; // result will be null
```

### 10.手写 nextTick 方法

```js{1-17,20-22}
export function myNextTick(fn) {
  let app = document.getElementById("app");
  var observerOptions = {
    childList: true, //观察目标子节点的变化
    attributes: true, //观察属性变动
    subtree: true, //观察后代节点，默认为false
  };

  //让fn()在DOM更新完成后执行
  //创建一个DOM监听器
  let observer = new MutationObserver((el) => {
    //当被监听的DOM更新完成时，该回调会触发
    console.log(el);
    fn();
  });
  observer.observe(app, observerOptions);
}

// 另一种
function nextTick(fn){
    Promise.resolve().then(fn)
}
```

### 11.allComplete

```js
// 手写一个方法，使用Promise.all，实现所有都resolved/reject时才返回，并返回所有的结果
let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(100);
  }, 1000);
});
let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(200);
  }, 2000);
});
let p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(300);
  }, 3000);
});

Promise.allSettled([p1, p2, p3]).then((val) => {
  console.log(val);
  //   [
  //     { status: "fulfilled", value: 100 },
  //     { status: "fulfilled", value: 200 },
  //     { status: "fulfilled", value: 300 },
  //   ];
});

//方法就是让他们全部进行兑现！
function allComplete(arr) {
  return Promise.all(
    arr.map((promise) => {
      return new Promise((resolve) => promise.then(resolve, resolve));
    })
  );
}
```

### 12.防抖与节流

```js
// 防抖与节流          共同点               区别               应用场景
// 防抖：debounce   在事件频繁触发时       只执行最后一次      input输入
// 节流：throttle   减少事件执行的次数     有规律地执行        拖拽、scroll

//防抖
function debounce(fn, delay) {
  let timer = null;
  return function (...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

//节流
function throttle(fn, delay) {
  let timer = null;
  return function (...args) {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args);
        timer = null;
      }, delay);
    }
  };
}

//节流的另一种写法
function throttle1(fn, delay) {
  let pre = 0;
  return function () {
    let now = new Date();
    if (now - pre > delay) {
      fn.apply(this, arguments);
      pre = now;
    }
  };
}
```

### 13.深拷贝浅拷贝

```js
let obj = {
  id: "1",
  name: "luoyu",
  msg: {
    age: 18,
  },
};
//浅拷贝：只会完整拷贝浅层，深层拷贝的是地址
let o = {};
for (let k in obj) {
  o[k] = obj[k];
}
o.msg.age = 20;
o.id = "2";
o.name = "luolin";
console.log(o);
console.log(obj); //深层中obj对象的msg.age受到影响

//还有一种浅拷贝操作
Object.assign(o, obj); //将obj浅拷贝给o,实际开发中用assign方法实现浅拷贝
console.log(o);
console.log(obj);

console.log("--------------------------");
//深拷贝：每一级数据都会被拷贝
o = {};
//封装函数
function deepCopy(newobj, oldobj) {
  for (let k in oldobj) {
    //判断我们的属性值属于哪种数据类型
    //1.获取属性值  oldobj[k]
    var item = oldobj[k];
    if (item instanceof Array) {
      //数组放在上面，因为数组也属于对象
      //2.判断这个值是否是数组
      newobj[k] = [];
      deepCopy(newobj[k], item);
    } else if (item instanceof Object) {
      //3.判断这个值是否是对象
      newobj[k] = {};
      deepCopy(newobj[k], item);
    } else {
      ///属于简单数据类型
      newobj[k] = item;
    }
  }
}
deepCopy(o, obj);
o.msg.age = 23; //对obj没有了影响
console.log(o);
console.log(obj);
```

### 14.判断两个对象是否相等
```js
// 先来看看JSON.stringify()
var obj1 = {
  a: 1,
  b: 2,
};
var obj2 = {
  a: 1,
  b: 2,
};
// 上面这种情况是相等的
console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); //true
// 这个方法看似简单，但是存在一个较大的缺点，就是对象结构稍微改变，结果就会有问题

obj1 = {
  a: 1,
  b: 2,
};
obj2 = {
  b: 2,
  a: 1,
};
// 调整了键的位置
console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // fasle

// 手写一个方法解决上面的问题
function isObjectValueEqual(a, b) {
  var aProps = Object.getOwnPropertyNames(a);
  var bProps = Object.getOwnPropertyNames(b);

  if (aProps.length !== bProps.length) {
    return false;
  }

  for (let i = 0; i < aProps.length; i++) {
    var propName = aProps[i];
    var propA = a[propName];
    var propB = b[propName];

    if (typeof propA === "object") {
      if (isObjectValueEqual(propA, propB)) {
        return true;
      } else {
        return false;
      }
    } else if (propA !== propB) {
      return false;
    }
  }
  return true;
}

console.log(isObjectValueEqual(obj1, obj2));

let hh = {
  a: {
    b: [1, 2, 3],
  },
};

let gg = {
  a: {
    b: [1, 2, 3],
  },
};
console.log(isObjectValueEqual(hh,gg));//true
```

## 手写 Promise

### 完整 Promise

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>手写Promise</h1>
    <script>
      const PENDING = "pending";
      const FULFILLED = "fulfilled";
      const REJECTED = "rejected";
      function runAsynctask(callback) {
        if (typeof queueMicrotask === "function") {
          queueMicrotask(callback);
        } else if (typeof MutationObserver === "function") {
          let obs = new MutationObserver(callback);
          let divNode = document.createElement("div");
          obs.observe(divNode, { childList: true });
          divNode.innerHTML = "RAIN";
        } else {
          setTimeout(callback, 0);
        }
      }
      function resolvePromise(p2, x, resolve, reject) {
        if (x === p2) reject(new TypeError("chining error in Promise"));
        if (x instanceof RainPromise) {
          x.then(
            (res) => resolve(res),
            (err) => reject(err)
          );
        } else {
          resolve(x);
        }
      }
      class RainPromise {
        state = PENDING;
        result = undefined;
        #handler = [];
        constructor(func) {
          const resolve = (res) => {
            if (this.state === PENDING) {
              this.state = FULFILLED;
              this.result = res;
              this.#handler.forEach((onFulfilled) => {
                onFulfilled();
              });
            }
          };
          const reject = (res) => {
            if (this.state === PENDING) {
              this.state = REJECTED;
              this.result = res;
              this.#handler.forEach((onRejected) => {
                onRejected();
              });
            }
          };

          func(resolve, reject);
        }
        // 实例方法 then()
        then(onFulfilled, onRejected) {
          onFulfilled =
            typeof onFulfilled === "function" ? onFulfilled : (x) => x;
          onRejected =
            typeof onRejected === "function"
              ? onRejected
              : (x) => {
                  throw x;
                };

          const p2 = new RainPromise((resolve, reject) => {
            if (this.state === FULFILLED) {
              runAsynctask(() => {
                try {
                  let x = onFulfilled(this.result);
                  if (x === p2)
                    reject(new TypeError("chining error in Promise"));
                  if (x instanceof RainPromise) {
                    x.then(
                      (res) => resolve(res),
                      (err) => reject(err)
                    );
                  } else {
                    resolve(x);
                  }
                } catch (err) {
                  reject(err);
                }
              });
            } else if (this.state === REJECTED) {
              runAsynctask(() => {
                try {
                  let x = onRejected(this.result);
                  resolvePromise(p2, x, resolve, reject);
                } catch (error) {
                  reject(error);
                }
              });
            } else if (this.state === PENDING) {
              this.#handler.push({
                onFulfilled: () => {
                  runAsynctask(() => {
                    try {
                      let x = onFulfilled(this.result);
                      resolvePromise(p2, x, resolve, reject);
                    } catch (error) {
                      reject(error);
                    }
                  });
                },
                onRejected: () => {
                  runAsynctask(() => {
                    try {
                      let x = onRejected(this.result);
                      resolvePromise(p2, x, resolve, reject);
                    } catch (error) {
                      reject(error);
                    }
                  });
                },
              });
            }
          });
          return p2;
        }

        /* 实例方法 catch */
        catch(undefined, onRejected) {
          return this.then(undefined, onRejected);
        }
        /* 实例方法 finally */
        finally(onFinally, onFinally) {
          return this.then(onFinally, onFinally);
        }
        /* 静态方法 resolve */
        static resolve(value) {
          if (value instanceof RainPromise) {
            return value;
          }
          return new RainPromise((resolve) => {
            resolve(value);
          });
        }
        /* 静态方法 reject */
        static reject(error) {
          return new RainPromise((undefined, reject) => {
            reject(error);
          });
        }
        /* 静态方法 race */
        static race(promises) {
          return new RainPromise((resolve, reject) => {
            if (!Array.isArray(promises)) {
              return reject(new TypeError("Argument is not Array"));
            }
            //对空没有处理，那就是pending
            promises.forEach((p) => {
              RainPromise.resolve(p).then(
                (res) => {
                  resolve(res);
                },
                (err) => {
                  reject(err);
                }
              );
            });
          });
        }
        /* 静态方法 all */
        static all(promises) {
          return new RainPromise((resolve, reject) => {
            if (!Array.isArray(promises)) {
              return reject(new TypeError("Argument is not Array"));
            }
            promises.length === 0 && resolve(promises);
            const result = [];
            let count = 0;
            promises.forEach((p, index) => {
              RainPromise.resolve(p).then(
                (res) => {
                  result[index] = res;
                  count++;
                  count === promises.length && resolve(result);
                },
                (err) => {
                  reject(err);
                }
              );
            });
          });
        }
        /* 静态方法 allsettled */
        static allsettled(promises) {
          return new RainPromise((resolve, reject) => {
            if (!Array.isArray(promises)) {
              return reject(new TypeError("Argument is not Array"));
            }
            promises.length === 0 && resolve(promises);
            const result = [];
            let count = 0;
            promises.forEach((p, index) => {
              RainPromise.resolve(p).then(
                (res) => {
                  result[index] = { state: FULFILLED, value: res };
                  count++;
                  count === promises.length && resolve(result);
                },
                (err) => {
                  result[index] = { state: REJECTED, value: err };
                  count++;
                  count === promises.length && resolve(result);
                }
              );
            });
          });
        }
        /* 静态方法 any */
        static any(promises) {
          return new RainPromise((resolve, reject) => {
            if (!Array.isArray(promises)) {
              return reject(new TypeError("Argument is not Array"));
            }
            promises.length === 0 &&
              reject(new AggregateError(promises, "All promise were rejected"));
            const errors = [];
            let count = 0;
            promises.forEach((p, index) => {
              RainPromise.resolve(p).then(
                (res) => {
                  resolve(res);
                },
                (err) => {
                  errors[index] = err;
                  count++;
                  count === promises.length &&
                    reject(
                      new AggregateError(errors, "All promise were rejected")
                    );
                }
              );
            });
          });
        }
      }
    </script>
  </body>
</html>
```

### 01-构造函数

```js{9-19}
/**
 *  构造函数
 *  1.定义类
 *  2.添加构造函数
 *  3.定义resolve/reject
 *  4.执行回调函数
 * */
//1.定义类
class HMPromise {
  // 2.添加构造函数
  constructor(func) {
    //3.定义resolve/reject
    const resolve = (result) => {};
    const reject = (result) => {};

    //4.执行回调函数
    func(resolve, reject);
  }
}

/* 测试代码 */
let p = new HMPromise((resolve, reject) => {
  console.log("LLL");
  resolve("成功");
  // reject("失败")
});
```

### 02-状态及原因

```js{8-10,15-16,19-32}
/**
 *  状态及原因
 *  1.添加状态（pending/fulfilled/rejected）
 *  2.添加原因
 *  3.调整resolve/reject
 *  4.状态不可逆
 * */
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
      }
    };

    func(resolve, reject);
  }
}

/* 测试代码 */
let p = new HMPromise((resolve, reject) => {
  resolve("成功");
  reject("失败");
});
```

### 03-then 的方法-成功和失败的回调

```js{39-56}
/**
 *  成功和失败的回调
 *  1.添加实例方法
 *  2.参数判断（参考文档）
 *      2.1.执行成功的回调
 *      2.2.执行失败的回调
 *
 * */
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
      }
    };

    func(resolve, reject);
  }

  //1.添加实例方法
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    //执行成功的回调
    if (this.state === FULFILLED) {
      onFulfilled(this.result);
    } else if (this.state === REJECTED) {
      onRejected(this.result);
    }
  }
}

/* 测试代码 */
let p = new HMPromise((resolve, reject) => {
  resolve("成功");
  reject("失败");
});

p.then(
  (val) => {
    console.log(val);
  },
  (err) => {
    console.log(err);
  }
);
```

### 04-then 的方法

```js{20,30-32,39-41,64-70}
/**
 *  异步及多次调用
 *  1.定义实例属性
 *  2.保存回调函数
 *  3.调用成功的回调
 *  4.调用失败的回调
 *
 * */
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;
  // 定义实例属性，用来保存我们的回调函数
  //# 私有的，外部访问不到
  #handlers = []; //[{onFulfilled,onRejected}...]

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
        //遍历取出
        this.#handlers.forEach(({ onFulfilled }) => {
          onFulfilled(this.result);
        });
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
        this.#handlers.forEach(({ onRejected }) => {
          onRejected(this.result);
        });
      }
    };

    func(resolve, reject);
  }

  //1.添加实例方法
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    //执行成功的回调
    if (this.state === FULFILLED) {
      onFulfilled(this.result);
    } else if (this.state === REJECTED) {
      onRejected(this.result);
    } else if (this.state === PENDING) {
      //是pending状态的时候还不需要去执行函数，可以先保存起来
      this.#handlers.push({
        onFulfilled,
        onRejected,
      });
    }
  }
}

/* 测试代码 */
let p = new HMPromise((resolve, reject) => {
  setTimeout(() => {
    resolve("成功");
    // reject("失败")
  }, 2000);
});

p.then(
  (val) => {
    console.log("then1" + val);
  },
  (err) => {
    console.log("then1" + err);
  }
);

p.then(
  (val) => {
    console.log("then2" + val);
  },
  (err) => {
    console.log("then2" + err);
  }
);
```

### 05-异步任务 API

```js{84-117}
/**
 *  异步及多次调用
 *  1.定义实例属性
 *  2.保存回调函数
 *  3.调用成功的回调
 *  4.调用失败的回调
 *
 * */
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;
  // 定义实例属性，用来保存我们的回调函数
  //# 私有的，外部访问不到
  #handlers = []; //[{onFulfilled,onRejected}...]

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
        //遍历取出
        this.#handlers.forEach(({ onFulfilled }) => {
          onFulfilled(this.result);
        });
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
        this.#handlers.forEach(({ onRejected }) => {
          onRejected(this.result);
        });
      }
    };

    func(resolve, reject);
  }

  //1.添加实例方法
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    //执行成功的回调
    if (this.state === FULFILLED) {
      onFulfilled(this.result);
    } else if (this.state === REJECTED) {
      onRejected(this.result);
    } else if (this.state === PENDING) {
      //是pending状态的时候还不需要去执行函数，可以先保存起来
      this.#handlers.push({
        onFulfilled,
        onRejected,
      });
    }
  }
}

/* 测试代码 */
console.log("top");
let p = new HMPromise((resolve, reject) => {
  resolve("success");
});
p.then((val) => {
  console.log(val);
});
console.log("bottom");

/**
 * 异步任务：
 * Vue：Promise.then,MutationObserver,setImmediate,setTimeout
 * 我们选用：queueMicrotask MutationObserver setTimeout
 *    Promise.then：手写Promise，不考虑这个
 *    queueMicrotask:node11，新式浏览(不包括IE11)
 *    MutationObserver：node不支持，IE11支持
 *    setImmediate：IE10,11，支持，edge12-18支持（不考虑）
 *    setTimeout:node，浏览器
 * */

//    ---------------异步任务1  queueMicrotask  -----------------
console.log(1);
queueMicrotask(() => {
  console.log("queueMicrotask");
});
console.log(2);

//    ---------------异步任务2 MutationObserver -----------------
console.log(1);
// 创建观察者，并传入回调函数
const obs = new MutationObserver(() => {
  console.log("mutationObserver");
});
//创建元素，并添加监听
const divNode = document.createElement("div");
//参数1 观察DOM节点
//参数2 观察的选项（childList 观察子节点的改变）
obs.observe(divNode, { childList: true });
// 3.修改元素内容
divNode.innerHTML = "itheima 666";
console.log(2);

// ------------- 异步任务 setTimeout --------------------------------
```

### 06-异步任务-函数封装

```js{9-20,75-97}
/**
 * 异步任务-函数封装
 *  1. 定义函数
 *  2. 调用核心API（queueMicrotask,MutationObserver,setTimeout）
 *  3. 使用封装函数
 */

// 函数封装
function runAsynctask(callback) {
  if (typeof queueMicrotask === "function") {
    queueMicrotask(callback);
  } else if (typeof MutationObserver === "function") {
    const obs = new MutationObserver(callback);
    const divNode = document.createElement("div");
    obs.observe(divNode, { childList: true });
    divNode.innerHTML = "hhh";
  } else {
    setTimeout(callback, 0);
  }
}

const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;
  // 定义实例属性，用来保存我们的回调函数
  //# 私有的，外部访问不到
  #handlers = []; //[{onFulfilled,onRejected}...]

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
        //遍历取出
        this.#handlers.forEach(({ onFulfilled }) => {
          // onFulfilled(this.result)
          onFulfilled();
        });
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
        this.#handlers.forEach(({ onRejected }) => {
          // onRejected(this.result)
          onRejected();
        });
      }
    };

    func(resolve, reject);
  }

  //1.添加实例方法
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    //执行成功的回调
    if (this.state === FULFILLED) {
      runAsynctask(() => {
        onFulfilled(this.result);
      });
    } else if (this.state === REJECTED) {
      runAsynctask(() => {
        onRejected(this.result);
      });
    } else if (this.state === PENDING) {
      //是pending状态的时候还不需要去执行函数，可以先保存起来
      this.#handlers.push({
        onFulfilled: () => {
          runAsynctask(() => {
            onFulfilled(this.result);
          });
        },
        onRejected: () => {
          runAsynctask(() => {
            onRejected(this.result);
          });
        },
      });
    }
  }
}

/* 测试代码 */
console.log("top");
let p = new HMPromise((resolve, reject) => {
  resolve("success");
});
p.then((val) => {
  console.log(val);
});
console.log("bottom");
```

### 7-链式编程-处理返回值异常

```js
/**
 * 链式编程-处理返回值和普通内容（fulfilled状态）
 * 1.返回新Promise实例
 * 2.获取返回值
 *  2.1.处理返回值
 *  2.2.处理异常
 */

// 函数封装
function runAsynctask(callback) {
  if (typeof queueMicrotask === "function") {
    queueMicrotask(callback);
  } else if (typeof MutationObserver === "function") {
    const obs = new MutationObserver(callback);
    const divNode = document.createElement("div");
    obs.observe(divNode, { childList: true });
    divNode.innerHTML = "hhh";
  } else {
    setTimeout(callback, 0);
  }
}

const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;
  // 定义实例属性，用来保存我们的回调函数
  //# 私有的，外部访问不到
  #handlers = []; //[{onFulfilled,onRejected}...]

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
        //遍历取出
        this.#handlers.forEach(({ onFulfilled }) => {
          // onFulfilled(this.result)
          onFulfilled();
        });
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
        this.#handlers.forEach(({ onRejected }) => {
          // onRejected(this.result)
          onRejected();
        });
      }
    };

    func(resolve, reject);
  }

  // then方法
  // 1.返回新Promise实例
  // 2.获取任意返回值
  // 2.1处理返回值
  // 2.2处理异常
  //1.添加实例方法
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    const p2 = new HMPromise((resolve, reject) => {
      //执行成功的回调
      if (this.state === FULFILLED) {
        runAsynctask(() => {
          try {
            //获取返回值
            const x = onFulfilled(this.result);
            // console.log("x",x);
            //处理返回值
            resolve(x);
          } catch (error) {
            // console.log("捕获异常："+error);
            reject(error);
          }
        });
      } else if (this.state === REJECTED) {
        runAsynctask(() => {
          onRejected(this.result);
        });
      } else if (this.state === PENDING) {
        //是pending状态的时候还不需要去执行函数，可以先保存起来
        this.#handlers.push({
          onFulfilled: () => {
            runAsynctask(() => {
              onFulfilled(this.result);
            });
          },
          onRejected: () => {
            runAsynctask(() => {
              onRejected(this.result);
            });
          },
        });
      }
    });
    return p2;
  }
}

/* 测试代码 */
const p = new HMPromise((resolve, reject) => {
  resolve(1);
});
p.then((res) => {
  console.log("p1", res);
  throw "throw-err";
  return 2;
}).then(
  (res) => {
    console.log("p2", res);
  },
  (err) => {
    console.log("p2", err);
  }
);
```

### 8-链式编程-处理返回 Promise

```js
/**
 * 链式编程-处理返回值Promise
 * 1.处理返回值Promise
 * 2.调用then方法
 */

// 函数封装
function runAsynctask(callback) {
  if (typeof queueMicrotask === "function") {
    queueMicrotask(callback);
  } else if (typeof MutationObserver === "function") {
    const obs = new MutationObserver(callback);
    const divNode = document.createElement("div");
    obs.observe(divNode, { childList: true });
    divNode.innerHTML = "hhh";
  } else {
    setTimeout(callback, 0);
  }
}

const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;
  // 定义实例属性，用来保存我们的回调函数
  //# 私有的，外部访问不到
  #handlers = []; //[{onFulfilled,onRejected}...]

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
        //遍历取出
        this.#handlers.forEach(({ onFulfilled }) => {
          // onFulfilled(this.result)
          onFulfilled();
        });
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
        this.#handlers.forEach(({ onRejected }) => {
          // onRejected(this.result)
          onRejected();
        });
      }
    };

    func(resolve, reject);
  }

  // then方法
  // 1.返回新Promise实例
  // 2.获取任意返回值
  // 2.1处理返回值
  // 2.2处理异常
  //1.添加实例方法
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    const p2 = new HMPromise((resolve, reject) => {
      //执行成功的回调
      if (this.state === FULFILLED) {
        runAsynctask(() => {
          try {
            //获取返回值
            const x = onFulfilled(this.result);
            // console.log("x",x);
            // 1.处理返回值Promise
            if (x instanceof HMPromise) {
              //2.调用then方法
              x.then(
                (res) => resolve(res),
                (err) => reject(err)
              );
            } else {
              //处理返回值
              resolve(x);
            }
          } catch (error) {
            // console.log("捕获异常："+error);
            reject(error);
          }
        });
      } else if (this.state === REJECTED) {
        runAsynctask(() => {
          onRejected(this.result);
        });
      } else if (this.state === PENDING) {
        //是pending状态的时候还不需要去执行函数，可以先保存起来
        this.#handlers.push({
          onFulfilled: () => {
            runAsynctask(() => {
              onFulfilled(this.result);
            });
          },
          onRejected: () => {
            runAsynctask(() => {
              onRejected(this.result);
            });
          },
        });
      }
    });
    return p2;
  }
}

/* 测试代码 */
const p = new HMPromise((resolve, reject) => {
  resolve(1);
});
p.then((res) => {
  return new HMPromise((resolve, reject) => {
    // resolve(1)
    reject("err");
  });
}).then(
  (res) => {
    console.log("p2", res);
  },
  (err) => {
    console.log("p2", err);
  }
);
```

### 9-链式编程-处理重复引用

```js
/**
 * 链式编程-处理重复引用
 */

// 函数封装
function runAsynctask(callback) {
  if (typeof queueMicrotask === "function") {
    queueMicrotask(callback);
  } else if (typeof MutationObserver === "function") {
    const obs = new MutationObserver(callback);
    const divNode = document.createElement("div");
    obs.observe(divNode, { childList: true });
    divNode.innerHTML = "hhh";
  } else {
    setTimeout(callback, 0);
  }
}

const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;
  // 定义实例属性，用来保存我们的回调函数
  //# 私有的，外部访问不到
  #handlers = []; //[{onFulfilled,onRejected}...]

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
        //遍历取出
        this.#handlers.forEach(({ onFulfilled }) => {
          // onFulfilled(this.result)
          onFulfilled();
        });
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
        this.#handlers.forEach(({ onRejected }) => {
          // onRejected(this.result)
          onRejected();
        });
      }
    };

    func(resolve, reject);
  }

  // then方法
  // 1.返回新Promise实例
  // 2.获取任意返回值
  // 2.1处理返回值
  // 2.2处理异常
  //1.添加实例方法
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    const p2 = new HMPromise((resolve, reject) => {
      //执行成功的回调
      if (this.state === FULFILLED) {
        runAsynctask(() => {
          try {
            //获取返回值
            const x = onFulfilled(this.result);
            //处理重复引用
            if (x === p2) {
              throw new TypeError(
                "Chaining cycle detected for promise #<Promise>"
              );
            }
            // console.log("x",x);
            // 1.处理返回值Promise
            if (x instanceof HMPromise) {
              //2.调用then方法
              x.then(
                (res) => resolve(res),
                (err) => reject(err)
              );
            } else {
              //处理返回值
              resolve(x);
            }
          } catch (error) {
            // console.log("捕获异常："+error);
            reject(error);
          }
        });
      } else if (this.state === REJECTED) {
        runAsynctask(() => {
          onRejected(this.result);
        });
      } else if (this.state === PENDING) {
        //是pending状态的时候还不需要去执行函数，可以先保存起来
        this.#handlers.push({
          onFulfilled: () => {
            runAsynctask(() => {
              onFulfilled(this.result);
            });
          },
          onRejected: () => {
            runAsynctask(() => {
              onRejected(this.result);
            });
          },
        });
      }
    });
    return p2;
  }
}

/* 原生Promise测试 */
//    const p=new Promise((resolve,reject)=>{
//     resolve(1)
//    })
//    const p2=p.then(res=>{
//     return p2
//    })
/* 报错信息：Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise> */

/* 测试  手写Promise */
const p = new HMPromise((resolve, reject) => {
  resolve(1);
});

const p2 = p.then((res) => {
  return p2;
});

p2.then(
  (res) => {},
  (err) => {
    console.log("err", err);
  }
);
```

### 10-链式编程-rejected 状态

```js
// 函数封装
function runAsynctask(callback) {
  if (typeof queueMicrotask === "function") {
    queueMicrotask(callback);
  } else if (typeof MutationObserver === "function") {
    const obs = new MutationObserver(callback);
    const divNode = document.createElement("div");
    obs.observe(divNode, { childList: true });
    divNode.innerHTML = "hhh";
  } else {
    setTimeout(callback, 0);
  }
}

const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;
  // 定义实例属性，用来保存我们的回调函数
  //# 私有的，外部访问不到
  #handlers = []; //[{onFulfilled,onRejected}...]

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
        //遍历取出
        this.#handlers.forEach(({ onFulfilled }) => {
          // onFulfilled(this.result)
          onFulfilled();
        });
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
        this.#handlers.forEach(({ onRejected }) => {
          // onRejected(this.result)
          onRejected();
        });
      }
    };

    func(resolve, reject);
  }

  // then方法
  //1.处理异常
  // 2.获取返回值
  // 3.抽取函数
  // 4.调用函数
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    const p2 = new HMPromise((resolve, reject) => {
      //执行成功的回调
      if (this.state === FULFILLED) {
        runAsynctask(() => {
          try {
            //获取返回值
            const x = onFulfilled(this.result);
            //处理重复引用
            if (x === p2) {
              throw new TypeError(
                "Chaining cycle detected for promise #<Promise>"
              );
            }
            // console.log("x",x);
            // 1.处理返回值Promise
            if (x instanceof HMPromise) {
              //2.调用then方法
              x.then(
                (res) => resolve(res),
                (err) => reject(err)
              );
            } else {
              //处理返回值
              resolve(x);
            }
          } catch (error) {
            // console.log("捕获异常："+error);
            reject(error);
          }
        });
      } else if (this.state === REJECTED) {
        runAsynctask(() => {
          //1.处理异常
          try {
            //2.获取返回值
            const x = onRejected(this.result);
            //3.下面有一步进行函数抽取的
            //4 调用函数
            resolvePromise(p2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        });
      } else if (this.state === PENDING) {
        //是pending状态的时候还不需要去执行函数，可以先保存起来
        this.#handlers.push({
          onFulfilled: () => {
            runAsynctask(() => {
              // 1.处理异常
              try {
                //2.获取返回值
                const x = onFulfilled(this.result);
                //3.调用函数
                resolvePromise(p2, x, resolve, reject);
              } catch (error) {
                reject(error);
              }
            });
          },
          onRejected: () => {
            runAsynctask(() => {
              // 1.处理异常
              try {
                //2.获取返回值
                constx = onRejected(this.result);
                //3.调用函数
                resolvePromise(p2, x, resolve, reject);
              } catch (error) {
                reject(error);
              }
            });
          },
        });
      }
    });
    return p2;
  }
}

//3.抽取函数
function resolvePromise(p2, x, resolve, reject) {
  if (x === p2) {
    throw new TypeError("Chaining cycle detected for promise #<Promise>");
  }
  // console.log("x",x);
  // 1.处理返回值Promise
  if (x instanceof HMPromise) {
    //2.调用then方法
    x.then(
      (res) => resolve(res),
      (err) => reject(err)
    );
  } else {
    //处理返回值
    resolve(x);
  }
}

/* 原生Promise测试 */
//    const p=new Promise((resolve,reject)=>{
//     resolve(1)
//    })
//    const p2=p.then(res=>{
//     return p2
//    })
/* 报错信息：Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise> */

/* 测试  手写Promise */
const p = new HMPromise((resolve, reject) => {
  setTimeout(() => {
    resolve(1);
  }, 2000);
});

const p2 = p.then((res) => {
  throw "error";
  //  return p2
  // return 2
  return new HMPromise((resolve, reject) => {
    resolve("HMPromise-2");
  });
});

p2.then(
  (res) => {
    console.log("res:", res);
  },
  (err) => {
    console.log("err", err);
  }
);
```

### 11-实例方法-catch-finally

```js
// 函数封装
function runAsynctask(callback) {
  if (typeof queueMicrotask === "function") {
    queueMicrotask(callback);
  } else if (typeof MutationObserver === "function") {
    const obs = new MutationObserver(callback);
    const divNode = document.createElement("div");
    obs.observe(divNode, { childList: true });
    divNode.innerHTML = "hhh";
  } else {
    setTimeout(callback, 0);
  }
}

const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;
  // 定义实例属性，用来保存我们的回调函数
  //# 私有的，外部访问不到
  #handlers = []; //[{onFulfilled,onRejected}...]

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
        //遍历取出
        this.#handlers.forEach(({ onFulfilled }) => {
          // onFulfilled(this.result)
          onFulfilled();
        });
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
        this.#handlers.forEach(({ onRejected }) => {
          // onRejected(this.result)
          onRejected();
        });
      }
    };

    //   处理异常
    try {
      func(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  // then方法
  //1.处理异常
  // 2.获取返回值
  // 3.抽取函数
  // 4.调用函数
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    const p2 = new HMPromise((resolve, reject) => {
      //执行成功的回调
      if (this.state === FULFILLED) {
        runAsynctask(() => {
          try {
            //获取返回值
            const x = onFulfilled(this.result);
            //处理重复引用
            if (x === p2) {
              throw new TypeError(
                "Chaining cycle detected for promise #<Promise>"
              );
            }
            // console.log("x",x);
            // 1.处理返回值Promise
            if (x instanceof HMPromise) {
              //2.调用then方法
              x.then(
                (res) => resolve(res),
                (err) => reject(err)
              );
            } else {
              //处理返回值
              resolve(x);
            }
          } catch (error) {
            // console.log("捕获异常："+error);
            reject(error);
          }
        });
      } else if (this.state === REJECTED) {
        runAsynctask(() => {
          //1.处理异常
          try {
            //2.获取返回值
            const x = onRejected(this.result);
            //3.下面有一步进行函数抽取的
            //4 调用函数
            resolvePromise(p2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        });
      } else if (this.state === PENDING) {
        //是pending状态的时候还不需要去执行函数，可以先保存起来
        this.#handlers.push({
          onFulfilled: () => {
            runAsynctask(() => {
              // 1.处理异常
              try {
                //2.获取返回值
                const x = onFulfilled(this.result);
                //3.调用函数
                resolvePromise(p2, x, resolve, reject);
              } catch (error) {
                reject(error);
              }
            });
          },
          onRejected: () => {
            runAsynctask(() => {
              // 1.处理异常
              try {
                //2.获取返回值
                constx = onRejected(this.result);
                //3.调用函数
                resolvePromise(p2, x, resolve, reject);
              } catch (error) {
                reject(error);
              }
            });
          },
        });
      }
    });
    return p2;
  }

  /**
   * catch方法
   * 1.内部调用then方法
   * 2.处理异常
   */
  catch(onRejected) {
    //1.内部调用then方法（MDN文档中说的如是）
    return this.then(undefined, onRejected);
  }

  /**
   * finally方法
   * 1.内部调用then方法
   */
  finally(onFinally) {
    return this.then(onFinally, onFinally);
  }
}

//3.抽取函数
function resolvePromise(p2, x, resolve, reject) {
  if (x === p2) {
    throw new TypeError("Chaining cycle detected for promise #<Promise>");
  }
  // console.log("x",x);
  // 1.处理返回值Promise
  if (x instanceof HMPromise) {
    //2.调用then方法
    x.then(
      (res) => resolve(res),
      (err) => reject(err)
    );
  } else {
    //处理返回值
    resolve(x);
  }
}

/* 测试  手写Promise */
const p = new HMPromise((resolve, reject) => {
  // resolve("LLLL")
  // reject("reject-err")
  //需要处理实例化的异常
  throw "throw err";
});

p.then((res) => {
  console.log("res", res);
})
  .catch((err) => {
    console.log("err", err);
  })
  .finally(() => {
    console.log("finally");
  });
```

### 12-静态方法

```js
// 函数封装
function runAsynctask(callback) {
  if (typeof queueMicrotask === "function") {
    queueMicrotask(callback);
  } else if (typeof MutationObserver === "function") {
    const obs = new MutationObserver(callback);
    const divNode = document.createElement("div");
    obs.observe(divNode, { childList: true });
    divNode.innerHTML = "hhh";
  } else {
    setTimeout(callback, 0);
  }
}

const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class HMPromise {
  // 添加状态（pending/fulfilled/rejected）
  // 添加原因
  state = PENDING;
  result = undefined;
  // 定义实例属性，用来保存我们的回调函数
  //# 私有的，外部访问不到
  #handlers = []; //[{onFulfilled,onRejected}...]

  constructor(func) {
    const resolve = (result) => {
      //状态不可逆
      if (this.state === PENDING) {
        //调整resolve/reject
        this.state = FULFILLED;
        this.result = result;
        //遍历取出
        this.#handlers.forEach(({ onFulfilled }) => {
          // onFulfilled(this.result)
          onFulfilled();
        });
      }
    };
    const reject = (result) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.result = result;
        this.#handlers.forEach(({ onRejected }) => {
          // onRejected(this.result)
          onRejected();
        });
      }
    };

    //   处理异常
    try {
      func(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  // then方法
  //1.处理异常
  // 2.获取返回值
  // 3.抽取函数
  // 4.调用函数
  then(onFulfilled, onRejected) {
    //2.参数判断（参考文档）
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (x) => x;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (x) => {
            throw x;
          };

    const p2 = new HMPromise((resolve, reject) => {
      //执行成功的回调
      if (this.state === FULFILLED) {
        runAsynctask(() => {
          try {
            //获取返回值
            const x = onFulfilled(this.result);
            //处理重复引用
            if (x === p2) {
              throw new TypeError(
                "Chaining cycle detected for promise #<Promise>"
              );
            }
            // console.log("x",x);
            // 1.处理返回值Promise
            if (x instanceof HMPromise) {
              //2.调用then方法
              x.then(
                (res) => resolve(res),
                (err) => reject(err)
              );
            } else {
              //处理返回值
              resolve(x);
            }
          } catch (error) {
            // console.log("捕获异常："+error);
            reject(error);
          }
        });
      } else if (this.state === REJECTED) {
        runAsynctask(() => {
          //1.处理异常
          try {
            //2.获取返回值
            const x = onRejected(this.result);
            //3.下面有一步进行函数抽取的
            //4 调用函数
            resolvePromise(p2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        });
      } else if (this.state === PENDING) {
        //是pending状态的时候还不需要去执行函数，可以先保存起来
        this.#handlers.push({
          onFulfilled: () => {
            runAsynctask(() => {
              // 1.处理异常
              try {
                //2.获取返回值
                const x = onFulfilled(this.result);
                //3.调用函数
                resolvePromise(p2, x, resolve, reject);
              } catch (error) {
                reject(error);
              }
            });
          },
          onRejected: () => {
            runAsynctask(() => {
              // 1.处理异常
              try {
                //2.获取返回值
                constx = onRejected(this.result);
                //3.调用函数
                resolvePromise(p2, x, resolve, reject);
              } catch (error) {
                reject(error);
              }
            });
          },
        });
      }
    });
    return p2;
  }

  /**
   * catch方法
   * 1.内部调用then方法
   * 2.处理异常
   */
  catch(onRejected) {
    //1.内部调用then方法（MDN文档中说的如是）
    return this.then(undefined, onRejected);
  }

  /**
   * finally方法
   * 1.内部调用then方法
   */
  finally(onFinally) {
    return this.then(onFinally, onFinally);
  }

  /**
   * 静态方法-resolve
   * 1.判断传入值
   * 2.1.Promise直接返回
   * 2.2.转为Promise并返回(fulfilled状态)
   */
  static resolve(value) {
    //1.判断传入值
    if (value instanceof HMPromise) {
      // 2.1.Promise直接返回
      return value;
    }
    // 2.2.转为Promise并返回(fulfilled状态)
    return new HMPromise((resolve) => {
      resolve(value);
    });
  }

  /**
   *  静态方法-reject
   * 1.返回rejected状态的Promise
   *  */
  static reject(value) {
    // 1.返回rejected状态的Promise
    return new HMPromise((undefined, reject) => {
      reject(value);
    });
  }

  /**
   * 静态方法啊-race
   * 1、返回Promise
   * 2、判断是否为数组 错误信息（Argument is not iterable）
   * 3、等待一个敲定
   */
  static race(promises) {
    //1、返回一个Promise
    return new HMPromise((resolve, reject) => {
      //2、判断是否为数组
      if (!Array.isArray(promises)) {
        return reject(new TypeError("Argument is not iterable"));
      }
      // 3、等待一个敲定
      promises.forEach((p) => {
        HMPromise.resolve(p).then(
          (res) => resolve(res),
          (err) => {
            reject(err);
          }
        );
      });
    });
  }

  /**
   * 静态方法-all
   * 1.返回Promise实例
   * 2.判断是否为数组 错误信息 ：Argument is not iterable
   * 3.空数组直接兑现
   * 4.处理全部兑现
   *    4.1记录结果
   *    4.2.判断全部兑现
   * 5.处理第一个拒绝
   */
  static all(promises) {
    //1.返回Promise实例
    return new Promise((resolve, reject) => {
      // 2.判断是否为数组
      if (!Array.isArray(promises)) {
        return reject(new TypeError("Argument is not iterable"));
      }
      // 3.空数组直接兑现
      promises.length === 0 && resolve(promises);
      // 4.1记录结果
      const result = [];
      let count = 0;
      promises.forEach((p, index) => {
        HMPromise.resolve(p).then(
          (res) => {
            result[index] = res; //用索引来填充数组，不要去用push
            //4.2.判断全部兑现，用次数来判断(保证能获取到所有的结果！！！)，不要用记录结果数组的长度判断
            count++;
            count === promises.length && resolve(result);
          },
          (err) => {
            // 5.处理第一个拒绝
            reject(err);
          }
        );
      });
    });
  }

  /**
   * 静态方法- allsettled
   * 1.返回Promise
   * 2.数组判断 错误信息：Argument is not iterable
   * 3.为空数组直接敲定
   * 4.等待全部敲定
   * 4.1记录结果
   * 4.2处理兑现{status:'fulfilled',value:''}
   * 4.3处理拒绝{status:'rejected',reason:''}
   */
  static allSettled(promises) {
    //1.返回Promise
    return new HMPromise((resolve, reject) => {
      //2.数组判断
      if (!Array.isArray(promises)) {
        return reject(new TypeError("Argument is not iterable"));
      }
      //3.数组为空直接敲定
      promises.length === 0 && resolve(promises);
      //4.等待全部敲定
      //4.1记录结果
      const result = [];
      let count = 0;
      promises.forEach((p, index) => {
        HMPromise.resolve(p).then(
          (res) => {
            // 4.2处理兑现{status:'fulfilled',value:''}
            result[index] = { status: FULFILLED, value: res };
            count++;
            count === promises.length && resolve(result);
          },
          (err) => {
            // 4.3处理拒绝{status:'rejected',reason:''}
            result[index] = { status: REJECTED, reason: err };
            count++;
            count === promises.length && resolve(result);
          }
        );
      });
    });
  }

  /**
   * 静态方法-any
   * 1.返回Promise，数组判断 错误信息：Argument is not iterable
   * 2.空数组直接拒绝 aggregateError: All promise were rejected
   * AggregateError([错误原因1...],All Promise were rejected)
   * 3.等待结果
   *  3.1.第一个兑现
   *  3.2.全部拒绝
   */
  static any(promises) {
    // 返回Promise，数组判断
    return new HMPromise((resolve, reject) => {
      if (!Array.isArray(promises)) {
        return reject(new TypeError("Argument is not iterable"));
      }
      // 2.空数组直接拒绝 aggregateError: All promise were rejected
      promises.length === 0 &&
        reject(new AggregateError(promises, "All promise were rejected"));
      //3.等待结果
      const errors = [];
      let count = 0;
      promises.forEach((p, index) => {
        HMPromise.resolve(p).then(
          (res) => {
            //3.1 第一个兑现
            resolve(res);
          },
          (err) => {
            //3.2 全部拒绝
            errors[index] = err;
            count++;
            count === promises.length &&
              reject(new AggregateError(errors, "All promise were rejected"));
          }
        );
      });
    });
  }
}

//3.抽取函数
function resolvePromise(p2, x, resolve, reject) {
  if (x === p2) {
    throw new TypeError("Chaining cycle detected for promise #<Promise>");
  }
  // console.log("x",x);
  // 1.处理返回值Promise
  if (x instanceof HMPromise) {
    //2.调用then方法
    x.then(
      (res) => resolve(res),
      (err) => reject(err)
    );
  } else {
    //处理返回值
    resolve(x);
  }
}

/* 静态方法 resolve*/
HMPromise.resolve(
  new HMPromise((resolve, reject) => {
    // resolve("成功")
    // reject("失败")
    // throw "error"
  })
).then(
  (res) => {
    console.log("res", res);
  },
  (err) => {
    console.log("err", err);
  }
);

HMPromise.resolve("hello").then((res) => {
  // console.log("res",res);
});

/* 静态方法 reject */
HMPromise.reject("error").catch((res) => {
  // console.log("res",res);
});

/* 测试代码 race */
//   const p1=new HMPromise((resolve,reject)=>{
//     setTimeout(()=>{
//         resolve(1)
//     },2000)
//   })
//   const p2=new HMPromise((resolve,reject)=>{
//     setTimeout(()=>{
//         reject(2)
//     },1000)
//   })

//   HMPromise.race([p1,p2,"itheima"]).then(res=>{
//     console.log("res",res);
//   },err=>{
//     console.log("err",err);
//   })

/* 测试代码 - all */
// const p1=HMPromise.resolve(1)
// const p2=new HMPromise((resolve,reject)=>{
//   setTimeout(()=>{
//       resolve(2)
//       // reject("error")
//   },1000)
// })
// const p3=3;
// HMPromise.all([p1,p2,p3]).then(res=>{
//   console.log("res",res);
// },err=>{
//   console.log("err",err);
// })

/**测试代码 原生Promise
 *   */
// const p1 =HMPromise.resolve(1)
// const p2=2;
// const p3=new HMPromise((resolve,reject)=>{
//   setTimeout(()=>{
//     reject(3)
//   },1000)
// })

/* 静态方法 测试 -- allsettled */
// HMPromise.allSettled([p1,p2,p3]).then(res=>{
//   console.log("res",res);
// },err=>{
//   console.log("err",err);
// })

/**
 * 原生静态方法--Promise.allsettled
 * 1.传入Promise都变成已敲定，即可获取兑现的结果
 * 2.结果数组[{status: 'fulfilled', value: 1},
 * {status: 'fulfilled', value: 2}
 * {status: 'rejected', reason: 3}]
 * 3.结果数组的顺序和传入的Promise数组顺序一致
 * 4.空数组直接兑现
 * 5.不传入数组，直接报错
 */
// Promise.allSettled([p1,p2,p3]).then(res=>{
//   console.log("res",res);
// },err=>{
//   console.log("err",err);
// })

/** 测试代码  原生 Promise */
const p1 = new HMPromise((resolve, reject) => {
  setTimeout(() => {
    reject(1);
  }, 2000);
});

const p2 = 2;

const p3 = new HMPromise((resolve, reject) => {
  setTimeout(() => {
    resolve(3);
    // reject(3)
  }, 1000);
});

/**
 * 测试静态方法-any
 * 1.参数：Promise数组
 * 2.结果：
 * 2.1获得第一个成功的原因！
 * 2.2获得所有的拒绝原因 aggregateError: All promise were rejected
 * 2.3 传入空数组，直接拒绝 aggregateError: All promise were rejected
 * 2.4 不传入数组，直接报错
 */
// Promise.any([p1,p2,p3]).then(res=>{
//   console.log("res",res);
// },err=>{
//   console.log("err",err);
// })

/* 测试手写 Any */
HMPromise.any([]).then(
  (res) => {
    console.log("res", res);
  },
  (err) => {
    console.dir(err);
  }
);
```

## 设计模式

### 单例模式

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>单例模式</title>
  </head>
  <body>
    <h1>单例模式</h1>
    <script>
      class SingleTon {
        static #instance;
        static getInstance() {
          if (this.#instance !== undefined) {
            this.#instance = new SingleTon();
          }
          return this.#instance;
        }
      }
      let s1 = SingleTon.getInstance();
      let s2 = SingleTon.getInstance();
      console.log(s1 === s2);
    </script>
  </body>
</html>
```

### 观察者模式

```js
// 被观察者
class Subject {
  constructor() {
    this.observerList = [];
  }

  addObserver(observer) {
    this.observerList.push(observer);
  }

  removeObserver(observer) {
    const index = this.observerList.findIndex((o) => o.name === observer.name);
    this.observerList.splice(index, 1);
  }

  notifyObservers(message) {
    const observers = this.observerList;
    observers.forEach((observer) => observer.notified(message));
  }
}
// 观察者
class Observer {
  constructor(name, subject) {
    this.name = name;
    // 观察者主动申请加入被观察者的列表
    if (subject) {
      subject.addObserver(this);
    }
  }

  notified(message) {
    console.log(this.name, "got message", message);
  }
}

//   使用
const subject = new Subject();
const observerA = new Observer("observerA", subject);
const observerB = new Observer("observerB");
subject.addObserver(observerB); //被观察者主动将观察者加入列表
subject.notifyObservers("Hello from subject");
subject.removeObserver(observerA);
subject.notifyObservers("Hello again");
```

### 发布订阅

```js
class PubSub {
  constructor() {
    this.messages = {};
    this.listeners = {};
  }

  publish(type, content) {
    const existContent = this.messages[type];
    if (!existContent) {
      this.messages[type] = [];
    }
    this.messages[type].push(content);
  }

  subscribe(type, cb) {
    const existListener = this.listeners[type];
    if (!existListener) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(cb);
  }

  notify(type) {
    const messages = this.messages[type];
    const subscribers = this.listeners[type] || [];
    subscribers.forEach((cb) => cb(messages));
  }
}

class Publisher {
  constructor(name, context) {
    this.name = name;
    this.context = context;
  }

  publish(type, content) {
    this.context.publish(type, content);
  }
}

class Subscriber {
  constructor(name, context) {
    this.name = name;
    this.context = context;
  }

  subscribe(type, cb) {
    this.context.subscribe(type, cb);
  }
}

function main() {
  const TYPE_A = "music";
  const TYPE_B = "movie";
  const TYPE_C = "novel";

  const pubsub = new PubSub();

  const publisherA = new Publisher("publisherA", pubsub);
  publisherA.publish(TYPE_A, "we are young");
  publisherA.publish(TYPE_B, "the silicon valley");
  const publisherB = new Publisher("publisherB", pubsub);
  publisherB.publish(TYPE_A, "stronger");
  const publisherC = new Publisher("publisherC", pubsub);
  publisherC.publish(TYPE_B, "imitation game");

  const subscriberA = new Subscriber("subscriberA", pubsub);
  subscriberA.subscribe(TYPE_A, (res) => {
    console.log("subscriberA received", res);
  });
  const subscriberB = new Subscriber("subscriberB", pubsub);
  subscriberB.subscribe(TYPE_C, (res) => {
    console.log("subscriberB received", res);
  });
  const subscriberC = new Subscriber("subscriberC", pubsub);
  subscriberC.subscribe(TYPE_B, (res) => {
    console.log("subscriberC received", res);
  });

  pubsub.notify(TYPE_A);
  pubsub.notify(TYPE_B);
  pubsub.notify(TYPE_C);
}

main();

// subscriberA received [ 'we are young', 'stronger' ]
// subscriberC received [ 'the silicon valley', 'imitation game' ]
// subscriberB received undefined
```

### 发布订阅另一种

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>发布订阅模式</title>
  </head>
  <body>
    <h1>发布订阅模式</h1>
    <button id="on">注册事件</button>
    <button id="off">注销事件event1</button>
    <button id="emit">触发事件</button>
    <button id="onOnce">注册一次性事件</button>
    <button id="emitOnce">触发一次性事件</button>
    <script>
      class PubSub {
        //存储事件
        #handlers = {
          //结构：事件名:[callback1,callback2]
        };
        //注册事件
        $on(event, func) {
          if (this.#handlers[event] == undefined) {
            this.#handlers[event] = [];
          }
          this.#handlers[event].push(func);
        }
        //触发事件
        $emit(event, ...args) {
          let funcs = this.#handlers[event] || [];
          funcs.forEach((callback) => {
            callback(...args);
          });
        }
        //注销事件
        $off(event) {
          this.#handlers[event] = undefined;
        }
        //一次性触发事件
        $once(event, callback) {
          this.$on(event, (...args) => {
            callback(...args);
            this.$off(event);
          });
        }
      }

      const bus = new PubSub();
      //进行测试
      on.addEventListener("click", function () {
        bus.$on("event1", () => console.log("event1"));
        bus.$on("event2", (a, b) => console.log(a, b));
        bus.$on("event2", (a, b) => console.log("event2", a, b));
      });
      emit.addEventListener("click", function () {
        bus.$emit("event1");
        bus.$emit("event2", 1, 2);
      });
      off.addEventListener("click", function () {
        bus.$off("event1");
      });
      onOnce.addEventListener("click", function () {
        bus.$once("event3", () => {
          console.log("读书很难吗？");
        });
      });
      emitOnce.addEventListener("click", function () {
        bus.$emit("event3");
      });
    </script>
  </body>
</html>
```
