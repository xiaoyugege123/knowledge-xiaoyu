# 双指针_滑动窗口🍨

## 27. 移除元素
```javascript
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let slow=0
    for(let fast=0;fast<nums.length;fast++){
        if(nums[fast]!=val){
            nums[slow]=nums[fast]
            slow++
        }
    }
    return slow
};
```
## 26. 删除有序数组中的重复项
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let slow=0
    for(let fast=0;fast<nums.length;fast++){
        if(nums[fast]!=nums[slow]){
            slow++
            nums[slow]=nums[fast]
        }
    }
    return slow+1
};
```
## 283. 移动零
```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let slow=0;
    for(let fast=0;fast<nums.length;fast++){
        if(nums[fast]!=0){
            nums[slow]=nums[fast]
            slow++
        }
    }
    for(let i=slow;i<nums.length;i++){
        nums[i]=0
    }
};
```
## 209. 长度最小的子数组
```javascript
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
    //用滑动窗口进行求解
    let start = 0, end = 0;
    const n = nums.length;
    let sum = 0, ans = n + 1;//这个尽量设一个较大的值
    while (end < n) {
        sum += nums[end]
        end++
        while (sum >= target) {
            ans = Math.min(ans, end - start)
            sum -= nums[start]
            start++
        }
    }
    return ans == n + 1 ? 0 : ans
};
```
## 904. 水果成篮
```javascript
/**
 * @param {number[]} fruits
 * @return {number}
 */
var totalFruit = function (fruits) {
    if (fruits.length <= 2) return fruits.length
    //用滑动窗口+哈希来求解
    const map = new Map()
    let right = 0, left = 0//left来进行标记
    let max = -Infinity
    while (right < fruits.length) {
        const type = fruits[right]
        right++
        //注意这个位置求值后下面结尾也要注意一下！！！
        const it = Array.from(map.values())
        max = Math.max(max, it.reduce((p, v) => p + v, 0))

        map.set(type, (map.get(type) || 0) + 1)


        while (map.size > 2) {
            const ty = fruits[left]
            left++
            map.set(ty, map.get(ty) - 1)

            if (map.get(ty) == 0) {
                map.delete(ty)
            }
        }

    }
    const it = Array.from(map.values())
    max = Math.max(max, it.reduce((p, v) => p + v, 0))

    return max == -Infinity ? fruits.length : max
};
```
