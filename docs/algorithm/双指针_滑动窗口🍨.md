# 双指针_滑动窗口🍨

## 27. 移除元素
```javascript
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let slow=0
    for(let fast=0;fast<nums.length;fast++){
        if(nums[fast]!=val){
            nums[slow]=nums[fast]
            slow++
        }
    }
    return slow
};
```
## 26. 删除有序数组中的重复项
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let slow=0
    for(let fast=0;fast<nums.length;fast++){
        if(nums[fast]!=nums[slow]){
            slow++
            nums[slow]=nums[fast]
        }
    }
    return slow+1
};
```
## 283. 移动零
```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let slow=0;
    for(let fast=0;fast<nums.length;fast++){
        if(nums[fast]!=0){
            nums[slow]=nums[fast]
            slow++
        }
    }
    for(let i=slow;i<nums.length;i++){
        nums[i]=0
    }
};
```
## 209. 长度最小的子数组
```javascript
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
    //用滑动窗口进行求解
    let start = 0, end = 0;
    const n = nums.length;
    let sum = 0, ans = n + 1;//这个尽量设一个较大的值
    while (end < n) {
        sum += nums[end]
        end++
        while (sum >= target) {
            ans = Math.min(ans, end - start)
            sum -= nums[start]
            start++
        }
    }
    return ans == n + 1 ? 0 : ans
};
```
## 904. 水果成篮
```javascript
/**
 * @param {number[]} fruits
 * @return {number}
 */
var totalFruit = function (fruits) {
    if (fruits.length <= 2) return fruits.length
    //用滑动窗口+哈希来求解
    const map = new Map()
    let right = 0, left = 0//left来进行标记
    let max = -Infinity
    while (right < fruits.length) {
        const type = fruits[right]
        right++
        //注意这个位置求值后下面结尾也要注意一下！！！
        const it = Array.from(map.values())
        max = Math.max(max, it.reduce((p, v) => p + v, 0))

        map.set(type, (map.get(type) || 0) + 1)


        while (map.size > 2) {
            const ty = fruits[left]
            left++
            map.set(ty, map.get(ty) - 1)

            if (map.get(ty) == 0) {
                map.delete(ty)
            }
        }

    }
    const it = Array.from(map.values())
    max = Math.max(max, it.reduce((p, v) => p + v, 0))

    return max == -Infinity ? fruits.length : max
};
```
## 11. 盛最多水的容器
```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    let maxA=0
    let left=0,right=height.length-1
    while(left<right){
        let area=Math.min(height[left],height[right])*(right-left)
        maxA=Math.max(maxA,area)
        if(height[left]<height[right]){
            left++
        }else{
            right--
        }
    }
    return maxA
};
```
## 15. 三数之和
```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    //这里有三个去重的点子
    const len=nums.length;
    const res=[];
    nums.sort((a,b)=>a-b)
    for(let i=0;i<len-2;i++){
        //第一点优化:但凡开始记录，后面的三数和绝对大于0
        if(nums[i]>0)break;
        //第二点优化：跳过重复的点  
        if(i>0 && nums[i]==nums[i-1])continue;
        let L=i+1,R=len-1
        while(L<R){
            const target=nums[i]+nums[L]+nums[R];
            if(target==0){
                res.push([nums[i],nums[L],nums[R]])
                //第三层优化：
                while(L<R && nums[L]==nums[L+1])L++
                while(L<R && nums[R]==nums[R+1])R--
                L++
                R--
            }else if(target<0){
                L++
            }else{
                R--
            }
        }
    }
    return res
};
```
**这个写得差点时间超限：**
```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    nums.sort((a,b)=>a-b)
    const res=[]
    for(let i=1;i<nums.length;i++){
        const first=nums[i-1];
        let left=i,right=nums.length-1
        while(left<right){
            const target=nums[left]+nums[right]+first;
            if(target==0){
                res.push([first,nums[left],nums[right]]+"")
                left++
                right--
            }
            else if(target<0){
                left++
            }else{
                right--
            }
        }
    }
    let result=[...new Set(res)].map(str=>str.split(",").map(s=>Number(s)))
    return result
};
```
## 42. 接雨水
```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (height) {
    //利用双指针方法进行求解！！！这个方法比较简单！！！
    let ans = 0;
    let left = 0, right = height.length - 1;
    let leftMax = 0, rightMax = 0
    while (left < right) {
        leftMax = Math.max(leftMax, height[left])
        rightMax = Math.max(rightMax, height[right])
        if (height[left] < height[right]) {
            ans += leftMax - height[left]
            left++
        } else {
            ans += rightMax - height[right]
            right--
        }
    }
    return ans
};
```
## 3. 无重复字符的最长子串
```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
    let window = {}
    let left = 0, right = 0
    let res = 0
    while (right < s.length) {
        const c = s[right]
        right++
        if (window[c]!=undefined) {//注意是这个undefined，说明这里的c已经有了！！！
            window[c]++
        } else {
            window[c] = 1
        }

        while (window[c] > 1) {
            const d = s[left]
            left++
            window[d]--
        }
        res = Math.max(res, right - left)
    }
    return res
};
```
**前面用了一个JS方法来求解的**
```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
    //滑动窗口问题
    let max = 0;
    let slow = 0, fast = 0;
    while (fast < s.length) {
        if (!s.slice(slow, fast).includes(s[fast])) {
            fast++
        } else {
            slow++
        }
        max = Math.max(fast - slow, max)
    }
    return max
};
```
