# 技巧_数学🍌

## 136.只出现一次的数字
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    //这里的空间复杂度挺高的！！！
    // let obj={}
    // nums.forEach((num,index)=>{
    //     if(obj[num]){
    //         obj[num]=obj[num]+1
    //     }else{
    //         obj[num]=1
    //     }
    // })
    // for(let key in obj){
    //     if(obj[key]==1){
    //         return key
    //     }
    // }

    //进行异或操作
    // 2 ^ 2 ^ 1 = 0 ^ 1 = 1
    let res=0
    for(const num of nums){
        res^=num
    }
    return res
};
```
## 31.下一个排列
```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
    let len=nums.length
    let i=len-2//注意这里为什么是这样！
    //从后开始寻找非降序的元素
    while(i>=0 && nums[i]>=nums[i+1]){
        i--
    }
    if(i>=0){
        let j=len-1
        while(j>=0 && nums[i]>=nums[j]){//从后往前走找到大于之前的那个数，进行交换
             j--
        }
        swap(nums,i,j)
    }
    reverse(nums,i+1)//翻转最开始找到数后面的的一些数字
};

function swap(nums,i,j){
    let tmp=nums[i]
    nums[i]=nums[j]
    nums[j]=tmp
}

function reverse(nums,start){
    let end=nums.length-1
    while(start<end){
        swap(nums,start,end)
        start++
        end--
    }
}
```
## 560. 和为 K 的子数组
```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
const subarraySum = (nums, k) => {
    /* 
    遍历 nums 之前，我们让 -1 对应的前缀和为 0，这样通式在边界情况也成立。
    即在遍历之前，map 初始放入 0:1 键值对（前缀和为0出现1次了）。
     */
    const map = { 0: 1 };//可以想象一下前几个的前缀和正好等于k
    let prefixSum = 0;
    let count = 0;

    for (let i = 0; i < nums.length; i++) {
        prefixSum += nums[i];
        /* 前缀和之差等于k，只关心等于 k 的前缀和之差出现的次数c，就知道了有c个子数组求和等于k。 */
        if (map[prefixSum - k]) {
            count += map[prefixSum - k];
        }

        if (map[prefixSum]) {
            map[prefixSum]++;
        } else {
            map[prefixSum] = 1;
        }
    }
    return count;
};
```
