# äºŒå‰æ ‘ ğŸˆ

## 94. äºŒå‰æ ‘çš„ä¸­åºéå†

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
  const result = [];
  const traverse = (root) => {
    if (root == null) return;
    traverse(root.left);
    result.push(root.val);
    traverse(root.right);
  };
  traverse(root);
  return result;
};
```

## 104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
  if (root == null) return 0;
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};
```

## 226. ç¿»è½¬äºŒå‰æ ‘

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {
  //åˆ¤æ–­ä¸å­˜åœ¨ç›´æ¥è¿”å›
  if (root == null) return root;
  //å­˜åœ¨è¿›è¡Œä¸‹é¢çš„å¤„ç†
  const tmp = root.left;
  root.left = root.right;
  root.right = tmp;
  //éå†
  invertTree(root.left);
  invertTree(root.right);

  return root;
};
```

## 101. å¯¹ç§°äºŒå‰æ ‘

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
  return dfs(root.left, root.right);
};

function dfs(left, right) {
  if (left == null && right == null) return true; //éƒ½æ²¡æœ‰
  if (left == null || right == null) return false; //åªæœ‰ä¸€ä¸ª
  if (left.val != right.val) return false; //ä¸¤è€…éƒ½æœ‰
  // æ³¨æ„ä¸‹é¢çš„ä¸€ä¸ªåˆ¤æ–­ï¼ï¼ï¼
  return dfs(left.left, right.right) && dfs(left.right, right.left);
}
```

## 543. äºŒå‰æ ‘çš„ç›´å¾„ â­

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function (root) {
  let maxLen = 0;
  // äºŒå‰æ ‘æœ€å¤§æ·±åº¦çš„å˜ç§ï¼
  const maxline = (root) => {
    if (root == null) return 0;
    const left = maxline(root.left);
    const right = maxline(root.right);
    maxLen = Math.max(maxLen, right + left);
    return Math.max(left, right) + 1;
  };
  maxline(root);
  return maxLen;
};
```

## 102. äºŒå‰æ ‘çš„å±‚åºéå†

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
  const queue = [root],
    res = []; //æ˜¯ç±»ä¼¼é˜Ÿåˆ—çš„æ“ä½œ
  if (root == null) return res; // æ³¨æ„è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ¡ä»¶åˆ¤æ–­

  while (queue.length) {
    const len = queue.length;
    const arr = [];
    for (let i = 0; i < len; i++) {
      const node = queue.shift();
      arr.push(node.val);
      if (node.left) {
        queue.push(node.left);
      }
      if (node.right) {
        queue.push(node.right);
      }
    }
    res.push(arr);
  }
  return res;
};
```

## 108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function (nums) {
  // æ³¨æ„è¿™ä¸ªå‡½æ•°å¸¦ä¸Šçš„ä¸¤ä¸ªå‚æ•°
  function buildTree(low, high) {
    if (low > high) return null; //æ³¨æ„è¿™é‡Œçš„ç»ˆæ­¢æ¡ä»¶
    // ä¸‹é¢è¿›è¡Œæ ‘çš„ç”Ÿæˆ
    const mid = Math.floor((low + high) / 2);
    const root = new TreeNode(nums[mid]);
    root.left = buildTree(low, mid - 1);
    root.right = buildTree(mid + 1, high);
    return root;
  }
  return buildTree(0, nums.length - 1);
};
```

## 98. éªŒè¯äºŒå‰æœç´¢æ ‘

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {
  //ä¸­åºéå†æ±‚è§£ï¼ï¼ï¼
  // äºŒå‰æœç´¢æ ‘ã€Œä¸­åºéå†ã€å¾—åˆ°çš„å€¼æ„æˆçš„åºåˆ—ä¸€å®šæ˜¯å‡åºçš„ï¼Œ
  // è¿™å¯ç¤ºæˆ‘ä»¬åœ¨ä¸­åºéå†çš„æ—¶å€™å®æ—¶æ£€æŸ¥å½“å‰èŠ‚ç‚¹çš„å€¼æ˜¯å¦å¤§äºå‰ä¸€ä¸ªä¸­åºéå†åˆ°çš„èŠ‚ç‚¹çš„å€¼å³å¯ã€‚
  let stack = [];
  let inorder = -Infinity;

  while (stack.length || root !== null) {
    // å…¥æ ˆèŠ‚ç‚¹
    while (root !== null) {
      stack.push(root);
      root = root.left;
    }
    root = stack.pop();
    // å¦‚æœä¸­åºéå†å¾—åˆ°çš„èŠ‚ç‚¹çš„å€¼å°äºç­‰äºå‰ä¸€ä¸ª inorderï¼Œè¯´æ˜ä¸æ˜¯äºŒå‰æœç´¢æ ‘
    if (root.val <= inorder) {
      return false;
    }
    inorder = root.val;
    root = root.right;
  }
  return true;
};
```

**Errorï¼ æ²¡æœ‰è€ƒè™‘å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½å¿…é¡»å¤§äºæˆ–å°äºæ ¹èŠ‚ç‚¹**

> ä¾‹å¦‚ï¼š[5,4,6,null,null,3,7]ï¼Œè¿™æ ·çš„åšæ³•åªæ˜¯è€ƒè™‘åœ¨ä¸¤å±‚é—´çš„å¯¹æ¯”ï¼

```js
var isValidBST = function (root) {
  if (root == null) return true;
  if (
    (root.left != null && root.val <= root.left.val) ||
    (root.right != null && root.right.val <= root.val)
  ) {
    return false;
  }
  return isValidBST(root.left) && isValidBST(root.right);
};
```

**å¦ä¸€ç§è§£é¢˜æ€è·¯ï¼šå…ˆéå†æ”¶é›†åœ¨è¿›è¡Œå¯¹æ¯”**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {
  //ç›´æ¥å¯ä»¥éå†å‡ºæ¥å†è¿›è¡Œå¯¹æ¯”
  const res = [];
  const travel = (root) => {
    if (root == null) return;
    travel(root.left);
    res.push(root.val);
    travel(root.right);
  };
  travel(root);
  let flag = true;
  for (let i = 1; i < res.length; i++) {
    if (res[i - 1] >= res[i]) flag = false;
  }
  return flag;
};
```

## 230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬ K å°çš„å…ƒç´ 

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function (root, k) {
  //ä¸­åºéå†æ‰¾ç¬¬kä¸ªå…ƒç´ 
  let i = 0,
    value;
  const travel = (root) => {
    if (root == null) return;
    travel(root.left);
    if (++i == k) {
      value = root.val;
      return;
    }
    travel(root.right);
  };
  travel(root);
  return value;
};
```

## 199. äºŒå‰æ ‘çš„å³è§†å›¾

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function (root) {
  return levelOrder(root);
};

function levelOrder(root) {
  let res = [],
    stack = [root];
  if (root == null) return [];

  while (stack.length) {
    let arr = [];
    let len = stack.length;
    for (let i = 0; i < len; i++) {
      const node = stack.shift();
      arr.push(node.val);
      if (node.left) {
        stack.push(node.left);
      }
      if (node.right) {
        stack.push(node.right);
      }
    }
    //è¿™é‡Œç›´æ¥pushæœ€åä¸€ä¸ªå°±è¡Œäº†ï¼ï¼ï¼
    res.push(arr[arr.length - 1]);
  }
  return res;
}
```

## 103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function (root) {
  if (root == null) return []; //æ³¨æ„è¿™é‡Œçš„ä¸€ä¸ªæ¡ä»¶åˆ¤æ–­ï¼ï¼ï¼

  const res = [],
    queue = [root];
  let order = true;
  while (queue.length) {
    let arr = [];
    let len = queue.length;
    for (let i = 0; i < len; i++) {
      const node = queue.shift();
      if (order) {
        arr.push(node.val);
      } else {
        arr.unshift(node.val);
      }
      if (node.left) {
        queue.push(node.left);
      }
      if (node.right) {
        queue.push(node.right);
      }
    }
    res.push(arr);
    order = !order;
  }
  return res;
};
```

## 114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function (root) {
  let list = [];
  travel(root, list);
  for (let i = 1; i < list.length; i++) {
    const prev = list[i - 1],
      cur = list[i];
    prev.left = null;
    prev.right = cur;
  }
};

function travel(root, list) {
  //å…ˆåºéå†è¿›è¡Œæ”¶é›†ï¼ï¼ï¼
  if (root == null) return;
  list.push(root);
  travel(root.left, list);
  travel(root.right, list);
}
```

## 105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
// ä¼˜åŒ–æ–¹æ¡ˆ
var buildTree = function (preorder, inorder) {
  const helper = (p_start, p_end, i_start, i_end) => {
    if (p_start > p_end) return null;
    const rootVal = preorder[p_start]; //æ ¹èŠ‚ç‚¹çš„å€¼
    const root = new TreeNode(rootVal); //æ ¹èŠ‚ç‚¹
    const mid = inorder.indexOf(rootVal); //æ ¹èŠ‚ç‚¹åœ¨
    let leftNum = mid - i_start; //å·¦å­æ ‘çš„èŠ‚ç‚¹æ•°
    root.left = helper(p_start + 1, p_start + leftNum, i_start, mid - 1);
    root.right = helper(p_start + leftNum + 1, p_end, mid + 1, i_end);
    return root;
  };
  return helper(0, preorder.length - 1, 0, inorder.length - 1);
};

//ç¬¬ä¸€ç§å†™æ³•
function buildTree(preorder, inorder) {
  if (preorder.length == 0 || inorder.length == 0) return null;
  const root = new TreeNode(preorder[0]);
  const mid = inorder.indexOf(preorder[0]);
  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));
  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));
  return root;
}
```

## 437. è·¯å¾„æ€»å’Œ III

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number}
 */
var pathSum = function (root, targetSum) {
  let ans = 0;
  const map = new Map();
  dfs(root, 0);
  return ans;
  // å‰ç¼€å’Œå®šä¹‰
  // ç”¨å®ƒå¹²ä»€ä¹ˆ
  // HashMapå­˜çš„æ˜¯ä»€ä¹ˆ
  // æ¢å¤çŠ¶æ€ä»£ç çš„æ„ä¹‰ï¼šé¢˜ç›®ä¸­å¯ä»¥æ‹¿ node å€¼ä¸º5çš„èŠ‚ç‚¹æ¥è¯´

  function dfs(root, preSum) {
    if (root == null) return;
    let target = preSum + root.val;
    map.set(preSum, (map.get(preSum) || 0) + 1);
    ans += map.get(target - targetSum) || 0;

    dfs(root.left, target);
    dfs(root.right, target);

    map.set(preSum, map.get(preSum) - 1);
  }
};
```

## 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function (root, p, q) {
  const travel = (root, p, q) => {
    if (root == null || root == p || root == q) return root;
    let left = travel(root.left, p, q);
    let right = travel(root.right, p, q);

    // åç»­éå†ä¸­è¿›è¡Œå¤„ç†ï¼éœ€è¦è¿›è¡Œå¾€ä¸Šè¿”å›ï¼
    if (left != null && right != null) return root;
    if (left == null) return right;
    if (right == null) return left;
  };

  return travel(root, p, q);
};
```

## 124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
const maxPathSum = (root) => {
  let maxSum = Number.MIN_SAFE_INTEGER; // æœ€å¤§è·¯å¾„å’Œ

  const dfs = (root) => {
    if (root == null) {
      // éå†åˆ°nullèŠ‚ç‚¹ï¼Œæ”¶ç›Š0
      return 0;
    }
    const left = dfs(root.left); // å·¦å­æ ‘æä¾›çš„æœ€å¤§è·¯å¾„å’Œ
    const right = dfs(root.right); // å³å­æ ‘æä¾›çš„æœ€å¤§è·¯å¾„å’Œ

    const innerMaxSum = left + root.val + right; // å½“å‰å­æ ‘å†…éƒ¨çš„æœ€å¤§è·¯å¾„å’Œ
    maxSum = Math.max(maxSum, innerMaxSum); // æŒ‘æˆ˜æœ€å¤§çºªå½•

    const outputMaxSum = root.val + Math.max(left, right); // å½“å‰å­æ ‘å¯¹å¤–æä¾›çš„æœ€å¤§å’Œ

    // å¦‚æœå¯¹å¤–æä¾›çš„è·¯å¾„å’Œä¸ºè´Ÿï¼Œç›´æ¥è¿”å›0ã€‚å¦åˆ™æ­£å¸¸è¿”å›
    return outputMaxSum < 0 ? 0 : outputMaxSum;
  };

  dfs(root); // é€’å½’çš„å…¥å£

  return maxSum;
};
```

## 100. ç›¸åŒçš„æ ‘

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
//å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚
var isSameTree = function (p, q) {
  if (p == null && q == null) return true;
  if (p == null || q == null) return false;
  if (p.val != q.val) return false;
  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

## 298. äºŒå‰æ ‘æœ€é•¿è¿ç»­åºåˆ—
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestConsecutive = function(root) {
    let res = 0;
    let step = 0;
    //ç¬¬ä¸€æ­¥:æ ¹æ®é¢˜ç›®æ˜¯ æ±‚æœ€é•¿è¿ç»­åºåˆ—è·¯å¾„çš„é•¿åº¦; æ‰€ä»¥dfs è¦æ±‚ä¸€æ¡è¾¹çš„æœ€é•¿è¿ç»­åºåˆ—è·¯å¾„ çš„é•¿åº¦ã€‚
    function dfs(root){
        if(!root) return 0;

        //ç¬¬äºŒæ­¥: dfs(root.left); æ±‚rootèŠ‚ç‚¹å·¦å­æ ‘æœ€é•¿è¿ç»­åºåˆ—è·¯å¾„çš„é•¿åº¦;
        //ç¬¬ä¸‰æ­¥: dfs(root.right);æ±‚rootèŠ‚ç‚¹å³å­æ ‘æœ€é•¿è¿ç»­åºåˆ—è·¯å¾„çš„é•¿åº¦;
        let left = dfs(root.left);
        let right = dfs(root.right);

        //ç¬¬å››æ­¥: å…³é”® æ ¹æ®é¢˜æ„è¦è¿ç»­ æ‰€ä»¥å¦‚æœå­èŠ‚ç‚¹å­˜åœ¨ä¸”å­èŠ‚ç‚¹çš„å€¼ ä¸ç­‰äºçˆ¶èŠ‚ç‚¹çš„å€¼+1; é‚£å°±ä¸æ˜¯è¿ç»­çš„;
        //æ‰€ä»¥æ±‚çˆ¶èŠ‚ç‚¹çš„æœ€é•¿è¿ç»­åºåˆ—è·¯å¾„çš„é•¿åº¦æ—¶, è¿™ä¸ªå­èŠ‚ç‚¹çš„æœ€é•¿è¿ç»­åºåˆ—è·¯å¾„çš„é•¿åº¦è®¾ä¸º0;
        if(root.left && root.val+1 !== root.left.val) left = 0;
        if(root.right && root.val+1 !== root.right.val) right = 0;

        //ç¬¬äº”æ­¥: åœ¨éå†çš„è¿‡ç¨‹ä¸­å–æ¯ä¸ªèŠ‚ç‚¹çš„æœ€é•¿è¿ç»­åºåˆ—è·¯å¾„çš„é•¿åº¦, å–æœ€å¤§çš„æœ€ä¸ºç­”æ¡ˆ;
        res = Math.max(res, left+1, right+1);
        //ç¬¬å…­æ­¥: è¿”å›å½“å‰èŠ‚ç‚¹æœ€é•¿è¿ç»­åºåˆ—è·¯å¾„çš„é•¿åº¦ã€‚
        return Math.max(left,right)+1
    }
    dfs(root);
    return res;
};

```