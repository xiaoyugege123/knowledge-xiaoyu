# 二叉树🍈

## 94. 二叉树的中序遍历
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
    const result = []
    const traverse = (root) => {
        if (root == null) return;
        traverse(root.left)
        result.push(root.val)
        traverse(root.right)
    }
    traverse(root)
    return result
};
```
## 104. 二叉树的最大深度
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(root==null)return 0
    return Math.max(maxDepth(root.left),maxDepth(root.right))+1
};
```
## 226. 翻转二叉树
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    //判断不存在直接返回
    if(root==null)return root
    //存在进行下面的处理
    const tmp=root.left
    root.left=root.right
    root.right=tmp
    //遍历
    invertTree(root.left)
    invertTree(root.right)

    return root
};
```
## 101. 对称二叉树
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return dfs(root.left,root.right)
};

function dfs(left,right){
    if(left==null && right==null)return true //都没有
    if(left==null || right==null)return false //只有一个
    if(left.val!=right.val)return false //两者都有
    return dfs(left.left,right.right) && dfs(left.right,right.left)
}   
```
## 543. 二叉树的直径
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    let maxLen=0
    const maxline=(root)=>{
        if(root==null)return 0
        const left=maxline(root.left)
        const right=maxline(root.right)
        maxLen=Math.max(maxLen,right+left)
        return Math.max(left,right)+1
    }
    maxline(root)
    return maxLen
};
```
## 102. 二叉树的层序遍历
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
    const queue = [root], res = [] //是类似队列的操作
    if(root==null)return res// 注意这里还有一个条件判断
  
    while (queue.length) {
        const len = queue.length
        const arr = []
        for (let i = 0; i < len; i++) {
            const node = queue.shift()
            arr.push(node.val)
            if (node.left) {
                queue.push(node.left)
            }
            if (node.right) {
                queue.push(node.right)
            }
        }
        res.push(arr)
    }
    return res
};
```
## 108. 将有序数组转换为二叉搜索树
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function (nums) {
    // 注意这个函数带上的两个参数
    function buildTree(low, high) {
        if (low > high) return null//注意这里的终止条件
        // 下面进行树的生成
        const mid = Math.floor((low + high) / 2)
        const root = new TreeNode(nums[mid])
        root.left = buildTree(low, mid - 1)
        root.right = buildTree(mid + 1, high)
        return root
    }
    return buildTree(0, nums.length - 1)
};
```
## 98. 验证二叉搜索树
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    //中序遍历求解！！！
    // 二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，
    // 这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。
    let stack = [];
    let inorder = -Infinity;

    while (stack.length || root !== null) {
        // 入栈节点
        while (root !== null) {
            stack.push(root);
            root = root.left;
        }
        root = stack.pop();
        // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
        if (root.val <= inorder) {
            return false;
        }
        inorder = root.val;
        root = root.right;
    }
    return true;
};
```
## 230. 二叉搜索树中第K小的元素
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
    //深度遍历 左根右
    let index=0
    let res
    const traverse=(root)=>{
        if(root==null) return
        traverse(root.left)
        if(++index==k)res=root.val
        traverse(root.right)        
    }

    traverse(root)
    return res
};
```
## 199. 二叉树的右视图
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function (root) {
    return levelOrder(root)
};


function levelOrder(root) {
    let res = [], stack = [root]
    if (root == null) return []

    while (stack.length) {
        let arr = []
        let len = stack.length
        for (let i = 0; i < len; i++) {
            const node = stack.shift()
            arr.push(node.val)
            if (node.left) {
                stack.push(node.left)
            }
            if (node.right) {
                stack.push(node.right)
            }
        }
        //这里直接push最后一个就行了！！！
        res.push(arr[arr.length-1])
    }
    return res
}
```
## 114. 二叉树展开为链表
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
    let list=[]
    travel(root,list)
    for(let i=1;i<list.length;i++){
        const prev=list[i-1],cur=list[i]
        prev.left=null
        prev.right=cur
    }
};

function travel(root,list){
    //先序遍历进行收集！！！
    if(root==null)return 
    list.push(root)
    travel(root.left,list)
    travel(root.right,list)
}
```
## 105. 从前序与中序遍历序列构造二叉树

