# çŸ©é˜µğŸ‡

## 1329. å°†çŸ©é˜µæŒ‰å¯¹è§’çº¿æ’åº
```javascript
/**
 * @param {number[][]} mat
 * @return {number[][]}
 */
var diagonalSort = function (mat) {
    const n = mat.length;
    const m = mat[0].length;
    const diag = new Array(m + n).fill().map(() => []);
    //å…ˆè¿›è¡Œæ”¶é›†ç®¡é“æ•°æ®
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            diag[i - j + m].push(mat[i][j]);
        }
    }
    //è¿›è¡Œæ’åº
    diag.forEach(d => d.sort((a, b) => b - a));
    //è¿›è¡Œå¡«å……
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            mat[i][j] = diag[i - j + m].pop();
        }
    }
    return mat;
};
```
## 54. èºæ—‹çŸ©é˜µ
```javascript
function spiralOrder(matrix: number[][]): number[] {
    const row = matrix.length, col = matrix[0].length;
    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    const total = row * col
    const visited = new Array(row).fill(0).map(() => new Array(col).fill(false));
    const res = [];
    let directionIndex = 0, curRow = 0, curCol = 0;
    for (let i = 0; i < total; i++) {
        res.push(matrix[curRow][curCol]);
        visited[curRow][curCol] = true;

        const nextRow = curRow + directions[directionIndex][0];
        const nextCol = curCol + directions[directionIndex][1];

        //åˆ¤æ–­éœ€ä¸éœ€è¦è¿›è¡Œè½¬å‘
        if ((nextRow < 0 || nextRow > row - 1 || nextCol < 0 || nextCol > col - 1) || (visited[nextRow][nextCol])) {
            directionIndex = (directionIndex + 1) % 4;
        }

        curRow += directions[directionIndex][0];
        curCol += directions[directionIndex][1]
    }
    return res;
};
```
## 59. èºæ—‹çŸ©é˜µ II
```ts
function generateMatrix(n: number): number[][] {
    const result=Array.from({length:n},()=>new Array(n).fill(0));
    let curRow=0,curCol=0;
    const direction=[[0,1],[1,0],[0,-1],[-1,0]];
    let directIndex=0;
    const visited=Array.from({length:n},()=>new Array(n).fill(false));
    for(let i=0;i<n*n;i++){
        result[curRow][curCol]=i+1;
        visited[curRow][curCol]=true;

        let nextRow=curRow+direction[directIndex][0];
        let nextCol=curCol+direction[directIndex][1];

        if(!(nextCol<n && nextRow<n && nextCol>=0 && nextRow>=0) || visited[nextRow][nextCol]){
            directIndex=(directIndex+1)%4;
        }

        curRow+=direction[directIndex][0]
        curCol+=direction[directIndex][1];
    }
    return result
};
```
## 885. èºæ—‹çŸ©é˜µ III
```js
/**
 * @param {number} rows
 * @param {number} cols
 * @param {number} rStart
 * @param {number} cStart
 * @return {number[][]}
 */
var spiralMatrixIII = function (rows, cols, rStart, cStart) {
    const result = Array.from({ length: rows * cols }, () => new Array(2).fill(0));
    const direction = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    let x = rStart, y = cStart, index = 0, directIndex = 0;
    let Left=cStart-1,Right=cStart+1,Top=rStart-1,Bottom=rStart+1;// å››ä¸ªæ–¹å‘çš„è¾¹ç•Œ
    while (index < rows * cols) {
        if (x >= 0 && x < rows && y >= 0 && y < cols) {
            result[index] = [x,y];
            index++
        }
        if(directIndex===0 && y===Right){// å‘å³åˆ°å³è¾¹ç•Œ
            directIndex+=1; // è°ƒè½¬æ–¹å‘å‘ä¸‹
            Right+=1; //å³è¾¹ç•Œå³ç§»
        }else if(directIndex===1 && x===Bottom){
            directIndex+=1
            Bottom+=1;
        }else if(directIndex===2 && y===Left){
            directIndex+=1;
            Left-=1;
        }else if(directIndex===3 && x===Top){
            directIndex=0;
            Top-=1;
        }
        x+=direction[directIndex][0];
        y+=direction[directIndex][1];
    }
    return result;
};
```
## 2326. èºæ—‹çŸ©é˜µ IV
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {number} m
 * @param {number} n
 * @param {ListNode} head
 * @return {number[][]}
 */
var spiralMatrix = function (m, n, head) {
    const result = Array.from({ length: m }, () => new Array(n).fill(-1));
    const direction = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    const visited=Array.from({length:m},()=>new Array(n).fill(false));
    let x=0,y=0,directIndex=0;
    let p=head
    while(p){
        result[x][y]=p.val
        visited[x][y]=true;
        p=p.next;
        let nextRow=x+direction[directIndex][0];
        let nextCol=y+direction[directIndex][1];
        if(!(nextRow>=0 && nextRow<m && nextCol>=0 && nextCol<n) || visited[nextRow][nextCol]){
            directIndex=(directIndex+1)%4
        }
        x+=direction[directIndex][0];
        y+=direction[directIndex][1];
    }
    return result
};
```
## 289. ç”Ÿå‘½æ¸¸æˆ
```javascript
/**
 * @param {number[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var gameOfLife = function (board) {
    const m = board.length, n = board[0].length
    const other = Array.from({ length: m }, () => new Array(n).fill(0))
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            const count = getSurvival(board, i, j)
            // æ³¨æ„ä¸èƒ½ç›´æ¥åœ¨èº«ä¸Šè¿›è¡Œæ“ä½œï¼Œè¦ä¸ç„¶ä¼šå¯¹åé¢çš„äº§ç”Ÿå½±å“
            if (count == 3) {
                other[i][j] = 1
            } else if (count == 2) {
                other[i][j] = board[i][j]
            } else {
                other[i][j] = 0
            }
        }
    }
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            board[i][j] = other[i][j]
        }
    }
};

// è·å–å…«ä¸ªç›¸é‚»ä½ç½®å­˜æ´»ä¸ªæ•°
function getSurvival(board, i, j) {
    const arr = [
        board[i]?.[j + 1],
        board[i]?.[j - 1],
        board[i + 1]?.[j],
        board[i + 1]?.[j - 1],
        board[i + 1]?.[j + 1],
        board[i - 1]?.[j],
        board[i - 1]?.[j + 1],
        board[i - 1]?.[j - 1]
    ]
    return arr.filter(item => item == 1).length
}
```
## 48. æ—‹è½¬å›¾åƒ
```javascript
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function (matrix) {
   //ä¸¤éå¾ªç¯çš„é—®é¢˜
   let n=matrix.length
   // æ³¨æ„ä¸‹é¢çš„åŒºå—é™åˆ¶ï¼Œè¦ä¸ç„¶ä¼šå¯¼è‡´è½¬åœˆæ¬¡æ•°è¿‡å¤š
   for(let i=0;i<Math.floor(n/2);i++){
    for(let j=0;j<Math.floor((n+1)/2);j++){
        let tmp=matrix[i][j]
        matrix[i][j]=matrix[n-1-j][i]
        matrix[n-1-j][i]=matrix[n-1-i][n-1-j]
        matrix[n-1-i][n-1-j]=matrix[j][n-1-i]
        matrix[j][n-1-i]=tmp
    }
   }
};
```
## 73. çŸ©é˜µç½®é›¶
```javascript
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
    const m=matrix.length,n=matrix[0].length;
    const iSet=new Set();
    const jSet=new Set();
    // å­˜å‚¨ä½ç½®
    for(let i=0;i<m;i++){
        for(let j=0;j<n;j++){
            if(matrix[i][j]===0){
                iSet.add(i);
                jSet.add(j);
            }
        }
    }
    // ä¿®æ”¹çŸ©é˜µ
    for(let i=0;i<m;i++){
        for(let j=0;j<n;j++){
            if(iSet.has(i)||jSet.has(j)){
                matrix[i][j]=0;
            }
        }
    }
};
```

## 41. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function (nums) {
    // æ—¶é—´å¤æ‚åº¦O(n),å¹¶ä¸”ä½¿ç”¨å¸¸æ•°çº§åˆ«çš„ç©ºé—´
    const map = [];
    for (let i = 0; i < nums.length; i++) {
        map[nums[i]] = true;
    }
    console.log(map, map.length)
    // ä»1å¼€å§‹å¾€åçœ‹ç©ºä½
    for (let i = 1; i < map.length; i++) {
        if (map[i] === undefined) {
            return i;
        }
    }
    // å¦‚æœmapçš„indexä¸º0è¿”å›1ï¼Œlengthä¸º0ä¹Ÿè¿”å›1
    if (map.length <= 1) return 1
    return map.length;
};
```