# åŠ¨æ€è§„åˆ’ğŸ“

## 70.çˆ¬æ¥¼æ¢¯
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
    const dp=[1,2]
    for(let i=2;i<n;i++){
        dp[i]=dp[i-1]+dp[i-2]
    }
    return dp[n-1]
};
```
## 118.æ¨è¾‰ä¸‰è§’
```javascript
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function (numRows) {
    // æ‰“å°è¾“å‡ºä¸€ä¸ªæ¨è¾‰ä¸‰è§’
    const dp = Array.from({ length: numRows }, () => new Array(numRows).fill(1))
    for (let i = 0; i < numRows; i++) {
        for (let j = 0; j < numRows; j++) {
            if (j > 0 && j < i) {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]
            }
        }
    }
    //è¿›è¡Œpushè¿›å»
    let res = []
    for (let i = 0; i < numRows; i++) {
        res.push(dp[i].slice(0, i + 1))
    }
    return res
};
```
## 198.æ‰“å®¶åŠ«èˆ
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
    //å¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ã€‚
    let len = nums.length
    if (len <= 2) return Math.max.apply(null, nums)
    let max = nums[0];
    let M = nums[0]
    let dp = [nums[0], nums[1]]
    if (max < dp[1]) max = dp[1]
    for (let i = 2; i < len; i++) {
        //è¿™ä¸ªMè¡¨ç¤ºé—´éš”ä¸¤ä½ä»¥ä¸Šçš„æœ€å¤§æ•°
        if (dp[i - 2] > M) M = dp[i - 2]
        dp[i] = M + nums[i]
        if (max < dp[i]) max = dp[i]
    }
    return max
};
```
## 279.å®Œå…¨å¹³æ–¹æ•°
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function (n) {
    //ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£
    let dp = new Array(n + 1).fill(0)//å…¶å®ä¸»è¦æ˜¯åˆå§‹åŒ–dp[0]
    //æ¯ä¸€ä¸ªå¯¹åº”çš„ä½ç½®æœ€å¤§å¯ä»¥æ˜¯æœ¬èº«1+1+1â€¦â€¦
    for (let i = 1; i <= n; i++) {
        dp[i] = i;//æ¯æ¬¡éƒ½å°†å½“å‰æ•°å­—å…ˆæ›´æ–°ä¸ºæœ€å¤§çš„ç»“æœï¼Œæœ€åçš„ç»“æœ
        //è¿™é‡Œçš„jæ˜¯å¹³æ–¹æ•°çš„åº•å­
        for (let j = 1; i - j * j >= 0; j++) {
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1)
        }
    }
    return dp[n]
};
```
## 322.é›¶é’±å…‘æ¢
```javascript
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    // å®šä¹‰dpæ•°ç»„
    let dp=new Array(amount+1).fill(Infinity)
    dp[0]=0
    //æ³¨æ„ä¸¤å±‚forå¾ªç¯çš„éå†ï¼Œåˆ†åˆ«éå†çš„æ˜¯å•¥ï¼Ÿ
    for(let i=0;i<coins.length;i++){
        for(let j=coins[i];j<=amount;j++){
            dp[j]=Math.min(dp[j],dp[j-coins[i]]+1)
        }
    }
    if(dp[amount]==Infinity)return -1
    return dp[amount]
};
```
## 300.æœ€é•¿é€’å¢å­åºåˆ—
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    let n=nums.length;
    let dp=new Array(n).fill(1)
    for(let i=1;i<n;i++){
        for(let j=0;j<i;j++){
            if(nums[i]>nums[j]){
                dp[i]=Math.max(dp[i],dp[j]+1)
            }
        }
    }
    return Math.max.apply(null,dp)
};
```
## 416.åˆ†å‰²ç­‰å’Œå­é›†
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
    // æ˜¾ç„¶æ˜¯0-1èƒŒåŒ…é—®é¢˜
    let n=nums.length
    let target=nums.reduce((p,v)=>p+v,0)/2
    if(!Number.isInteger(target))return false
    let dp=new Array(target+1).fill(0)
    for(let i=0;i<n;i++){
        for(let j=target;j>=nums[i];j--){
            dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i])
        }
    }
    return dp[target]==target
};
```
## 62.ä¸åŒè·¯å¾„
```javascript
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    let dp=Array.from({length:m},()=>new Array(n).fill(1))
    for(let i=1;i<m;i++){
        for(let j=1;j<n;j++){
            dp[i][j]=dp[i][j-1]+dp[i-1][j]
        }
    }
    return dp[m-1][n-1]
};
```
## 64.æœ€å°è·¯å¾„
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    let m=grid.length
    let n=grid[0].length
    let dp=Array.from({length:m},()=>new Array(n))
    dp[0][0]=grid[0][0]
    for(let i=0;i<m;i++){
        for(let j=0;j<n;j++){
            if(i==0 && j>0){
                dp[i][j]=dp[i][j-1]+grid[i][j]
            }
            if(j==0 && i>0){
                dp[i][j]=dp[i-1][j]+grid[i][j]
            }
            if(j>0 && i>0){
                dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j]
            }
        }
    }
    return dp[m-1][n-1]
};
```

## 1143. æœ€é•¿å…¬å…±å­åºåˆ—
```js
/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
var longestCommonSubsequence = function(text1, text2) {
    const m = text1.length, n = text2.length;
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    for (let i = 1; i <= m; i++) {
        const c1 = text1[i - 1];
        for (let j = 1; j <= n; j++) {
            const c2 = text2[j - 1];
            if (c1 === c2) {//éœ€è¦ç›¸ç­‰å†ä»ä¸Šä¸€å±‚åŠ 1
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
};
```
