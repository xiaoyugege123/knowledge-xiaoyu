# 其他的一些小问题

## proxy的优缺点？
**Object.defineProperty的缺陷:**

1. **无法检测到对象属性的新增或删除**

    由于js的动态性，可以为对象追加新的属性或者删除其中某个属性， 这点对经过Object.defineProperty方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性和删除属性，这就需要另外处理。

2. **不能监听数组的变化（对数组基于下标的修改、对于 .length 修改的监测）**

   vue在实现数组的响应式时，它使用了一些hack，把无法监听数组的情况通过重写数组的部分方法来实现响式，这也只限制在数组的push/pop/shift/unshift/splice/sort/reverse七个方法，其他数组方法及数组的使用则无法检测到， 解决方法主要是使用proxy属性,这个proxy属性是ES6中新增的一个属性,proxy属性也是一个构造函数,他也可以通过new的方式创建这个函数,表示修改某些操作的默认行为,等同于在语言层面做出修改,所以属于一种元编程proxy可以理解为在目标对象之前架设一层拦截,外界对该对象的访问,都必须经过这层拦截,因此提出了一种机制,可以对外界的网文进行过滤和改写,proxy这个词是代理,用来表示由他代理某些操作,可以译为代理器

**proxy代理的特点:**

- proxy直接代理的是整个对象而非对象属性
- proxy的代理针对的是整个对象而不是像object.defineProperty针对某个属性
- 只需要做一层代理就可以监听同级结构下的所有属性变化，包括新增的属性和删除的属性
- proxy代理身上定义的方法共有13种,其中我们最常用的就是set和get,但是他本身还有其他的13种方法

**proxy的劣势:**

兼容性问题,虽然proxy相对越object.defineProperty有很有优势,但是并不是说proxy,就是完全的没有劣势,主要表现在以下的两个方面:
1. proxy有兼容性问题,无完全的polyfill:
    proxy为ES6新出的API,浏览器对其的支持情况可在w3c规范中查到,通过查找我们可以知道,
    虽然大部分浏览器支持proxy特性,但是一些浏览器或者低版本不支持proxy,
    因此proxy有兼容性问题,那能否像ES6其他特性有polyfill解决方案呢?,
    这时我们通过查询babel文档,发现在使用babel对代码进行降级处理的时候,并没有合适的polyfill
2. 第二个问题就是性能问题,proxy的性能其实比promise还差,
        这就需要在性能和简单实用上进行权衡,例如vue3使用proxy后,
        其对对象及数组的拦截很容易实现数据的响应式,尤其是数组

        虽然proxy有性能和兼容性处理,但是proxy作为新标准将受到浏览器厂商重点持续的性能优化,
        性能这块会逐步得到改善

[面试官: 实现双向绑定Proxy比defineproperty优劣如何? - 掘金](https://juejin.cn/post/6844903601416978439)


## Vue的双向绑定原理（腾讯）
[vue的双向绑定原理与实现 - 掘金](https://juejin.cn/post/7080562890628923423#heading-29)

[安全验证 - 知乎](https://zhuanlan.zhihu.com/p/138710460)



## HTTP请求方法：幂等和非幂等？
**幂等性和安全性是http请求方法的特性, 比如 get请求方法是具有安全的**

**安全性(此次请求不会修改后台):**
> ** 仅指该方法的多次调用不会产生副作用，不涉及传统意义上的“安全”，这里的副作用是指资源状态。**
> **即，安全的方法不会修改资源状态，尽管多次调用的返回值可能不一样(被其他非安全方法修改过)。**

** **
**幂等性(多次请求一个url,返回值不变):**
> ** 是指该方法多次调用返回的效果(形式)一致，客户端可以重复调用并且期望同样的结果。一次调用和多次调用产生的效果是一致的，都是对一个变量进行赋值。**

**————————————————————————————————**
**方法名	安全性	幂等性	请求方法的作用**
**get			√	√	请求指定的页面信息，并返回实体主体**
**head		√	√	只请求页面的首部**
**options		√	√	允许客户端查看服务器的性能**
**delete		×	√	请求服务器删除指定的数据**
**put			×	√	从客户端向服务器传送的数据取代指定的文档的内容**
**post			×	×	请求服务器接受所指定的文档作为对所标识的URI的新的从属实体**
**————————————————————————————————**
| 方法名      | 安全性 |  幂等性   |请求方法的作用|
|:---:|:----:|:---: |:---|
| get      | √       | √   |请求指定的页面信息，并返回实体主体   |
| head      | √       | √   |只请求页面的首部 |
| options      | √       | √   |允许客户端查看服务器的性能  |
| delete      | ×       | √   |请求服务器删除指定的数据  |
| put      | ×       | √   |从客户端向服务器传送的数据取代指定的文档的内容 |
| post      | ×       | ×   |请求服务器接受所指定的文档作为对所标识的URI的新的从属实体 |


![method.png](http://picture.gptkong.com/20240515/2124de21be4b4b4a11b8f2505b3d75cb60.png)
**POST和GET谁更安全?**

**get更安全**

**get比post安全? -->get对于服务器是安全的–> get是幂等的,post是非幂等的**

**post更安全**

**① GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。**

**② 浏览器有跨域访问的限制，如果是get的话，jsonp很容易突破跨域的限制。但是post跨域比较不容易。**

为什么put和delete是幂等，而patch则是非幂等的？
**重点来了，put 和 patch 都是用于更新数据资源的。 区别 在于**
> **put 做更新操作时候是提交一整个更新后的实体（即全部），而不是需要修改的实体中的部分属性。当 URI 指向一个存在的资源，服务器要做的事就是查找并替换。**

> **patch 做更新操作的时候是请求中的实体是一组将要应用到实体的更改（即部分），而不是像 PUT 请求那样是要替换旧资源的实体。可以理解为：PATCH 请求中的实体保存的是修改资源的指令，该指令指导服务器来对资源做出修改。**



**怎么理解呢？要明白并理解 RESTful 核心就是 面向资源编程，如下：**

** PUT /flowers/1   #修改 序号为1的花（flowers） 的全部信息**

> **put【幂等】：用于更新资源，没有的话则执行创建操作。每次执行请求时都会先判断一下序号为1的花信息是否存在，不存在则创建，否则视为更新。很显然，请求携带的数据每次都是一样的，所以不论请求多少次，最终的结果都是后台存在这么一个资源（创建或更新）。**



** PATCH /flowers/1/variety/lily/num/331   #假设url采用pathinfo模式，修改 序号为1的花（flowers） 的品种信息为百合，数量修改位431朵**

> **patch【非幂等】：用于更新资源，即数据实体的一部分属性，该数据必然存在，否则失去更新意义。每次执行请求时都会先判断一下序号为1的花信息是否存在，存在则更新数据信息，这里有两个属性要改，做的处理可能是这样的：品种（variety）直接改为百合（lily），而数量（num）假设原本存在100朵，我们要修改到 431 朵，所以增加 331 朵。很显然，多次请求时，会重复增加 331 ，属性数量就无法保持 431 。而 PUT 请求不论执行多少次，属性数量永远都是 431 ， PATCH 则会改变，处于不可控的地位，所以说 PUT 方法是幂等的，而 PATCH 方法不是幂等的。**



** DELETE /flowers/1   #删除 序号为1的花（flowers） 的全部信息**

> **delete【幂等】： 用于删除资源，会将资源从后台删除。每次执行请求时都会先判断一下序号为1的花信息是否存在，存在则删除，否则不做任何操作。很显然，无论执行多少次资源的状态总是被删除的，不会有其它副作用的影响。**


## 内存泄漏问题？
[一文帮你解决前端开发中的内存泄露问题](https://zhuanlan.zhihu.com/p/411103328)

[前端常见内存泄漏及解决方案 - 掘金](https://juejin.cn/post/7065705130963763231)

[如何查找和解决前端内存泄漏问题？ - 排查和分析技巧详解 - 掘金](https://juejin.cn/post/7232127712642547770)

## 前端开发中，使用base64图片的弊端是什么？
1. 造成网页阻塞
弊端主要不在于 base64 编码后比原图要大，而是因为如果把大图片编码到 html / css 中，会造成后者体积明显增加，明显影响网页的打开速度。如果用外链图片的话，图片可以在页面渲染完成后继续加载，不会造成阻塞。如果 base64 是被编码到 css/js 中，是可以缓存的，因为 css/js 文件可以缓存。
假设base64编码后的字符串长度为256kb，用户的网速为每个连接32kb/s，而除去这个字符串外html大小仅为32kb，其中图片前后各16kb
那么不考虑其他资源加载的情况下，用户会先在半秒后看到这个图片上面的内容，然后花费8秒加载图片，再在半秒后看到完整的网页
2. 有兼容性问题
使用 base64 的另外一个弊端是 IE 的兼容性问题。IE 8 以下不支持 data url，IE 8 开始支持 data url，却有大小限制，32k（未测试）。
3. 用法上面的问题
还有一个问题是，如果构建工具比较落后（或者没有构建工具），手动插入 base64 是很蛋疼的，编辑器会卡到哭。


## 什么是Gzip？
gzip是一种数据的压缩格式，或者说是一种文件格式。
>Gzip原本用户UNIX系统的文件压缩，后来逐渐成为Internet最主流的数据压缩格式。当用户访问我们的web站点时，服务器就将我们的网页文件进行压缩，将压缩后的文件传输到客户端，对于纯文本文件我们可以至少压缩到原大小的40%，这样大大提高了传输效率，页面便可更快的加载出来。

gzip是一种数据的压缩格式，也可以说是文件格式。linux系统该文件后缀为.gz	。使用gzip需要web容器，浏览器的支持。
- 配置 js、text、json、css 这种纯文本进行压缩，效率极高
- 压缩需要消化CPU，对于大文件（音乐/视频/图片）的压缩，会增加服务器压力。